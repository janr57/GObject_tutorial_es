% señales.tex
%
% Copyright (C) 2024 José A. Navarro Ramón <janr.devel@gmail.com>
% 1) Código LuaLatex:
%    Licencia GPL-2.
% 2) Producto en pdf, postscript, etc.:
%    Licencia Creative Commons Recognition Share alike. (CC-BY-SA)

\section{Señales}
Las señales son un medio de comunicación entre objetos. Se emiten cuando ocurre o se completa algo.

Pasos para programar una señal:
\begin{enumerate}
  \tightlist
\item Registro de la señal. Una señal pertenece a un objeto, por lo que el registro se lleva a cabo en la
  función de inicialización de la clase del objeto.
\item Escritura de un manejador de señal (\emph{signal handler}). Un manejador es una función que
  se invoca cuando se emite cierta señal.
\item Conexión entre la señal y el manejador. Los manejadores se conectan a las señales mediante
  \texttt{g\_connect\_signal} u otra función perteneciente a la misma familia.
  \item Emisión de la señal.
  \end{enumerate}

  Los pasos uno y cuatro se realizan sobre el objeto al que pertenece la señal; el tercero se lleva a cabo
  generalmente fuera del objeto.

  El uso de las señales es complicado y llevaría mucho tiempo explicar todas sus características. El contenido
  de esta sección se limita al mínimo necesario para escribir una señal sencilla, y por lo tanto no es del todo
  preciso. Si se necesitara más  información, se podría consultar la guía de referencia de la API de
  \textsf{GObject}. Hay cuatro partes de la guía que describen las señales:
  \begin{itemize}
    \tightlist
  \item \href{https://docs.gtk.org/gobject/concepts.html#signals}
    {\emph{\textsf{Type System Concepts - signals}}}.
  \item \href{https://docs.gtk.org/gobject/#functions}
    {\textsf{Functions (g\_signal\_xxx  series)}}.
  \item   \href{https://docs.gtk.org/gobject/#function_macros}
    {\emph{\textsf{Function Macros (g\_signal\_xxx series)}}}.
  \item   \href{https://docs.gtk.org/gobject/tutorial.html#how-to-create-and-use-signals}
    {\emph{\textsf{GObject Tutorial -- How to create and use signals}}}.
\end{itemize}

\subsection{Registro de señales}
Aquí seguiremos utilizando los objetos \textsf{TDouble}. En particular, crearemos una señal que se emitirá
cuando ocurra una división por cero (\emph{division-by-zero}).
Primero, asignaremos un nombre a la señal, que podrá constar de letras, dígitos, guiones (-) y subrayados (\_).
El primer carácter del nombre debe ser una letra. Elegiremos pues, la cadena \texttt{"div-by-zero"}
como nombre de nuestra señal.

Hay cuatro funciones que nos permiten registrar una señal. Aquí usaremos \texttt{g\_signal\_new} para la
nuestra. Sus parámetros se muestran a continuación:
\begin{lstlisting}[language=C, numbers=none]
guint
g_signal_new (const gchar *signal_name,
              GType itype,
              GSignalFlags signal_flags,
              guint class_offset,
              GSignalAccumulator accumulator,
              gpointer accu_data,
              GSignalCMarshaller c_marshaller,
              GType return_type,
              guint n_params,
              ...);
\end{lstlisting}

Se necesita mucho tiempo para explicar cada parámetro. Por ahora, se mostrará la función
\texttt{g\_signal\_new} tal y como se utilizará en nuestro fichero \textsf{tdouble.c}. Los comentarios
en el código fuente se mantendrán en inglés, para que la traducción que no desvirtúe el
significado correcto:
\begin{lstlisting}[language=C, numbers=none]
t_double_signal =
g_signal_new ("div-by-zero",
              G_TYPE_FROM_CLASS (class),
              G_SIGNAL_RUN_LAST | G_SIGNAL_NO_RECURSE | G_SIGNAL_NO_HOOKS,
              0 /* class offset.Subclass cannot override the class handler (default handler). */,
              NULL /* accumulator */,
              NULL /* accumulator data */,
              NULL /* C marshaller. g_cclosure_marshal_generic() will be used */,
              G_TYPE_NONE /* return_type */,
              0     /* n_params */
              );
\end{lstlisting}

\begin{itemize}
  \tightlist
\item \texttt{t\_double\_signal} es una variable estática de tipo \texttt{guint}, que es equivalente a
  \texttt{unsigned int}. La función \texttt{g\_signal\_new} retorna este tipo a la variable que almacena la
  señal. 
\item El segundo parámetro es el tipo \texttt{GType} del objeto al que pertenece la señal.
  La macro \texttt{G\_TYPE\_FROM\_CLASS (class)} retorna el tipo que corresponde a la clase (\texttt{class},
  que es un puntero a la clase del objeto \footnotemark{}).
  \footnotetext{Recuerda que la función de inicialización de una clase (\texttt{g\_object\_class\_init})
    tiene un parámetro que, en nuestro ejemplo, se define \texttt{TDoubleClass *class}
    (ver, por ejemplo,  fichero \textsf{ejemplo05.c}, líneas 19--22.)}
\item El tercer parámetro es una bandera (\emph{flag}) de la señal. Se necesitan muchas páginas para
  explicar este parámetro. Así que por ahora, lo dejaremos tal y como está. Tal y como está este argumento
  en el ejemplo anterior se puede utilizar en muchas situaciones. En el enlace:
  \href{https://docs.gtk.org/gobject/flags.SignalFlags.html}
  {\emph{\textsf{GObject API Reference  - SignalFlags}}},
  se pueden consultar los \textsf{SignalFlags}.
\item El octavo parámetro es el tipo de sistema (\textsf{GType}) de retorno del manejador, que en este
  caso es \texttt{G\_TYPE\_NONE}, que significa que el manejador no retorna ningún valor cuando
  se ejecuta.
\item El noveno parámetro (\texttt{n\_params}) es el número de parámetros de la señal. La que
  estamos considerando aquí (\texttt{"div-by-zero"}) no tiene parámetros, por tanto ponemos un cero.
  Esto significa que no se insertan parámetros extra después de este.
\item Como se afirmó anteriormente, esta función se debe poner en la función de inicialización de la
  clase (\texttt{t\_double\_class\_init}).
\item Se pueden utilizar otras funciones, como \texttt{g\_signal\_newv}. Una descripción de esta
  última se puede ver en
  \href{https://docs.gtk.org/gobject/func.signal_newv.html}
  {\emph{\textsf{GObject API Reference - signal\_newv}}}.      
\end{itemize}

\subsection{Manejador de señal}
Un manejador de señal es una función que se ejecuta cuando se emite una cierta señal. Los manejadores
tienen dos parámetros:
\begin{itemize}
  \tightlist
\item La instancia a la que pertenece la señal.
\item Un puntero a unos datos de usuario (\emph{user data}) que se proporcionan cuando se conecta
  la señal al manejador. La señal \textsf{"div-by-zero"} no necesita datos de usuario.'
\end{itemize}

Para nuestro caso, el manejador sería algo así:
\begin{lstlisting}[language=C, numbers=none]
  void div_by_zero_cb (TDouble *self, gpointer user_data) { ... ... ...}
\end{lstlisting}
El primer argumento \texttt{self} es la instancia sobre la que se emite la señal. El segundo parámetro se
puede obviar:
\begin{lstlisting}[language=C, numbers=none]
  void div_by_zero_cb (TDouble *self) { ... ... ...}
\end{lstlisting}

Si una señal tiene parámetros, estos se insertan entre la instancia y los datos de usuario. Por ejemplo, el
manejador de la señal \textsf{"window-added"} en la instancia \textsf{GtkApplication} es:
\begin{lstlisting}[language=C, numbers=none]
  void window_added (GtkApplication* self, GtkWindow* window, gpointer user_data);
\end{lstlisting}
El segundo argumento \texttt{window} es el parámetro de la señal. La señal \textsf{"window-added"} se
emite cuando se añade una nueva ventana a la aplicación.
El parámetro \texttt{window} es un puntero a la ventana añadida. Ver la referencia a la API de GTK
para más información:
  \href{https://docs.gtk.org/gtk4/signal.Application.window-added.html}
  {\emph{\textsf{Gtk API Reference - window-added}}}.      

En nuestro caso, el manejador de \textsf{"div-by-zero"} mostrará un mensaje de error.
\begin{lstlisting}[language=C, numbers=none]
  static void
  div_by_zero_cb (TDouble *self, gpointer user_data) {
    g_print ("\nError: division by zero.\n\n");
  }
\end{lstlisting}

\subsection{Conexión de la señal}
Una señal y un manejador se conectan mediante la función \texttt{g\_signal\_connect}:
\begin{lstlisting}[language=C, numbers=none]
  g_signal_connect (self, "div-by-zero", G_CALLBACK (div_by_zero_cb), NULL);
\end{lstlisting}

\begin{itemize}
  \tightlist
\item El primer argumento, \texttt{self}, es la instancia a la que se conecta la señal.
\item El segundo argumento es el nombre de la señal.
\item El tercer argumento es el manejador de la señal, se debe utilizar con la macro
  \texttt{G\_CALLBACK} que ajusta el tipo de la función.
\item El último argumento representa los datos de usuario. Como la señal no los necesita,
  se asigna el valor \texttt{NULL}.
\end{itemize}

\subsection{Emisión de la señal}
La señales se emiten hacia el objeto u objetos asociados. El siguiente código se utilizará en
el próximo ejemplo de aplicación que usa el tipo \textsf{TDouble}:
\begin{lstlisting}[language=C, numbers=none]
  TDouble *
  t_double_div (TDouble *self, TDouble *other) {
    ... ... ...
    if ((! t_double_get_value (other, &value)))
    return NULL;
    else if (value == 0) {
      g_signal_emit (self, t_double_signal, 0);
      return NULL;
    }
    return t_double_new (self->value / value);
  }
\end{lstlisting}

\begin{itemize}
  \tightlist
\item El primer parámetro es la instancia que emite la señal.
\item El segundo parámetro es el identificador de la señal (\textsf{signal id}), que es el valor que
  retorna la función \texttt{g\_signal\_new}.
\item El tercer parámetro es un ``detalle'' (\textsf{detail}). \textsf{"div-by-zero"} no tiene ningún ``detalle'',
  por lo que el argumento es cero. Los ``detalles'' no se explican en esta sección, aunque generalmente se
  suele poner un cero como tercer argumento. si quieres saber algo sobre los ``detalles'', ver
  \href{https://docs.gtk.org/gobject/concepts.html#the-detail-argument}
  {\emph{\textsf{GObject API Reference - Signal Detail}}}.
  \item Cuando una señal tiene parámetros, estos se insertan a partir del cuarto argumento.
  \end{itemize}

\subsection{Ejemplo 8: señal de división por cero}
\subsubsection{Declaración del tipo \textsf{TDouble}: fichero de cabecera \textsf{tdouble.h}}
\begin{lstlisting}[language=C, numbers=left]
/*
 * tdouble.h
 * Declaración del tipo TDouble.
 */

#pragma once

#include <glib-object.h>

/* Declaración del tipo TDouble */
#define T_TYPE_DOUBLE (t_double_get_type ())
G_DECLARE_FINAL_TYPE(TDouble, t_double, T, DOUBLE, GObject)

/* Constructor de instancias de TDouble */
TDouble * t_double_new (double value);

/* Getter */
gboolean t_double_get_value (TDouble *self, double *value);

/* Setter */
void t_double_set_value (TDouble *self, double value);
  
/* Funciones aritméticas */
TDouble * t_double_add (TDouble *self, TDouble *other);
TDouble * t_double_sub (TDouble *self, TDouble *other);
TDouble * t_double_mul (TDouble *self, TDouble *other);
TDouble * t_double_div (TDouble *self, TDouble *other);
TDouble * t_double_uminus (TDouble *self);
\end{lstlisting}

\subsubsection{Definición del tipo \textsf{TDouble}: fichero \textsf{tdouble.c}}
\begin{lstlisting}[language=C, numbers=left]
/*
 * tdouble.c
 * Definición del tipo TDouble.
 */

#include "tdouble.h"

static guint t_double_signal;

/* Estructura que se declaró en tdouble.h como tipo C TDouble */
struct _TDouble {
  GObject parent;
  double value;
};

/* Definición del tipo TDouble */
/* Se lleva a cabo el registro del tipo del sistema TDouble,
   se define la función t_double_get_type, etc.
   y se crean algunas macros auxiliares, como T_IS_DOUBLE */
G_DEFINE_FINAL_TYPE (TDouble, t_double, G_TYPE_OBJECT);

/* Inicialización de la clase */
static void
t_double_class_init (TDoubleClass *class)
{
  t_double_signal = g_signal_new ("div-by-zero",
			  G_TYPE_FROM_CLASS (class),
			  G_SIGNAL_RUN_LAST | G_SIGNAL_NO_RECURSE | G_SIGNAL_NO_HOOKS,
			  0 /* Class offset. Una subclase no podría modificar el manejador de señal (manejador por defecto) */,
			  NULL /* acumulador */,
			  NULL /* datos del acumulador */,
			  NULL /* C marshaller. Se usará g_closure_marshal_generic() */,
			  G_TYPE_NONE /* Tipo de retorno del manejador */,
			  0 /* número de parámetros */
			  );
}

/* Inicialización del objeto */
static void
t_double_init (TDouble *self) {}

/* Constructor de objetos */
TDouble *
t_double_new (double value)
{
  TDouble *obj;
  
  obj = g_object_new (T_TYPE_DOUBLE, NULL);
  obj->value = value;
  
  return obj;
}

/* Getter */
gboolean
t_double_get_value (TDouble *self, double *value)
{
  g_return_val_if_fail (T_IS_DOUBLE (self), FALSE);
  *value = self->value;
  
  return TRUE;
}

/* Setter */
void
t_double_set_value (TDouble *self, double value)
{
  g_return_if_fail (T_IS_DOUBLE (self));
  self->value = value;
}

TDouble *
t_double_add (TDouble *self, TDouble *other)
{
    g_return_val_if_fail (T_IS_DOUBLE (self), NULL);
    g_return_val_if_fail (T_IS_DOUBLE (other), NULL);
    // El valor del parámetro 'other' se debe obtener mediante el método 'getter'
    double value;
    if (! t_double_get_value (other, &value)) {
      return NULL;
    }
    
    return t_double_new (self->value + value);
}

TDouble *
t_double_sub (TDouble *self, TDouble *other)
{
    g_return_val_if_fail (T_IS_DOUBLE (self), NULL);
    g_return_val_if_fail (T_IS_DOUBLE (other), NULL);
    // El valor del parámetro 'other' se debe obtener mediante el método 'getter'
    double value;
    if (! t_double_get_value (other, &value)) {
      return NULL;
    }

    return t_double_new (self->value - value);
}

TDouble *
t_double_mul (TDouble *self, TDouble *other)
{
    g_return_val_if_fail (T_IS_DOUBLE (self), NULL);
    g_return_val_if_fail (T_IS_DOUBLE (other), NULL);
    // El valor del parámetro 'other' se debe obtener mediante el método 'getter'
    double value;
    if (! t_double_get_value (other, &value)) {
      return NULL;
    }

    return t_double_new (self->value * value);
}

TDouble *
t_double_div (TDouble *self, TDouble *other)
{
    g_return_val_if_fail (T_IS_DOUBLE (self), NULL);
    g_return_val_if_fail (T_IS_DOUBLE (other), NULL);
    // El valor del parámetro 'other' se debe obtener mediante el método 'getter'
    double value;
    if (! t_double_get_value (other, &value)) {
      return NULL;
    } else if (value == 0) {
      g_signal_emit (self, t_double_signal, 0);
      return NULL;
    }
    
    return t_double_new (self->value / value);
}

TDouble *
t_double_aminus (TDouble *self)
{
    g_return_val_if_fail (T_IS_DOUBLE (self), NULL);

    return t_double_new (-self->value);
}
\end{lstlisting}

\subsubsection{Aplicación utilizando el tipo \textsf{TDouble}: fichero \textsf{main.c}}
\begin{lstlisting}[language=C, numbers=left]
/*
 * main.c
 * Comprobación del uso de señales.
 */

#include <stdlib.h>
#include <locale.h>

#include "tdouble.h"

static void
div_by_zero_cb (TDouble *self, gpointer user_data)
{
  g_printerr ("\nError: División entre cero.\n\n");
}

static void
t_print (char *op, TDouble *obj1, TDouble *obj2, TDouble *obj3)
{
  double v1, v2, v3;

  if (! t_double_get_value (obj1, &v1)) {
    return;
  }
  if (! t_double_get_value (obj2, &v2)) {
    return;
  }
  if (! t_double_get_value (obj3, &v3)) {
    return;
  }

  g_print ("%lf %s %lf = %lf\n", v1, op, v2, v3);
}

int
main (int argc, char **argv)
{
  TDouble *obj1, *obj2, *obj3;
  //double v1, v3;

  setlocale (LC_CTYPE, "");

  obj1 = t_double_new (10.0);
  obj2 = t_double_new (20.0);

  if ((obj3 = t_double_add (obj1, obj2)) != NULL) {
    t_print ("+", obj1, obj2, obj3);
    g_object_unref (obj3);
  }

  if ((obj3 = t_double_sub (obj1, obj2)) != NULL) {
    t_print ("-", obj1, obj2, obj3);
    g_object_unref (obj3);
  }

  if ((obj3 = t_double_mul (obj1, obj2)) != NULL) {
    t_print ("*", obj1, obj2, obj3);
    g_object_unref (obj3);
  }
 
  if ((obj3 = t_double_div (obj1, obj2)) != NULL) {
    t_print ("/", obj1, obj2, obj3);
    g_object_unref (obj3);
  }

   g_signal_connect (obj1, "div-by-zero", G_CALLBACK (div_by_zero_cb), NULL);
  t_double_set_value (obj2, 0.0);
  if ((obj3 = t_double_div (obj1, obj2)) != NULL) {
    t_print ("/", obj1, obj2, obj3);
    g_object_unref (obj3);
  }

  g_print ("Ok!\n");

  return EXIT_SUCCESS;
}
\end{lstlisting}

\subsubsection{Salida del ejemplo 7}
10.000000 + 20.000000 = 30.000000\par
10.000000 - 20.000000 = -10.000000\par
10.000000 * 20.000000 = 200.000000\par
10.000000 / 20.000000 = 0.500000\par
\vspace{1ex}
Error: División entre cero.\par
\vspace{1ex}
Ok!\par




  
%%% Local Variables:
%%% coding: utf-8
%%% mode: latex
%%% TeX-engine: luatex
%%% TeX-master: "../GObject_tutorial_es.tex"
%%% End:

% LaTeX-command: "lualatex --shell-escape"
