% registro.tex
%
% Copyright (C) 2024 José A. Navarro Ramón <janr.devel@gmail.com>
% 1) Código LuaLatex:
%    Licencia GPL-2.
% 2) Producto en pdf, postscript, etc.:
%    Licencia Creative Commons Recognition Share alike. (CC-BY-SA)

\section{Registro de objetos derivados, parámetros y métodos}
\subsection{Procedimiento para crear objetos derivados de \textsf{GObject}}
Para crear un tipo del sistema, a partir de un tipo en C, definido como una estructura ---en nuestro
ejemplo \texttt{TDouble}---, se llevan a cabo los siguientes pasos:
\begin{enumerate}
  \tightlist
\item Registro del tipo C, \texttt{TDouble}, en el sistema de tipos.
\item Asignación de memoria para \textsf{TDoubleClass} y \textsf{TDouble} del sistema de tipos.
\item Inicialización de \textsf{TDoubleClass}.
\item Inicialización de \textsf{TDouble}.
\end{enumerate}

\begin{figure}[ht]
  \centering
  \def\scl{1}
  \newcommand{\fondoTipoC}{green!20}
  \newcommand{\fondoTipoSistema}{green!25}
  \begin{tikzpicture}[%
    scale=\scl,
    every node/.style={font=\normalsize\sffamily},
    nubeSistemaTipos/.style={fill=yellow!75},
    nubeMemoria/.style={fill=black!2},
    tipoC/.style={fill=\fondoTipoC, font=\ttfamily, minimum size=8ex, inner sep=1em},
    tipoSistema/.style={fill=\fondoTipoSistema, minimum size=8ex, inner sep=1em},
    flecha/.style={line width=1.6pt, -Stealth[round]},  background/.style={
      line width=\bgborderwidth,
      draw=\bgbordercolor,
      fill=\bgcolor,
    },
    ]
    % COORDENADAS
    % - 
    % DIBUJO
    % Proceso de registro de una clase
    % Type System
    \node[nubeSistemaTipos, cloud, draw, aspect=2] (typesystem) % {Sistema de tipos};
    {\begin{tabular}{c} Sistema de Tipos \\ (\texttt{GType}) \end{tabular}};
    % Memoria
    \node[nubeMemoria, cloud, draw, aspect=2, right=12em of typesystem] (memory)
    {\begin{tabular}{c} Memoria \\ (TDoubleClass y TDouble) \end{tabular}};
    % TDouble (Tipo C)
    \node[tipoC, draw, above=8ex of typesystem] (tdoubleCtype)
    {\begin{tabular}{c}TDouble\\\textcolor{black!70}{(Tipo C)}\end{tabular}};
    % Objeto TDouble
    \node[tipoSistema, draw, below=8ex of memory] (tdoubleobject)
    {\begin{tabular}{c} Objeto TDouble \\ \textcolor{black!70}{(Tipo sistema)} \end{tabular}};
    % Clase TDoubleClass
    \node[tipoSistema, draw, left=12em of tdoubleobject] (tdoubleclass)
    {\begin{tabular}{c} Clase TDoubleClass \\ \textcolor{black!70}{(Tipo sistema)} \end{tabular}};
    % Flechas
    % TDouble (Tipo C) -> Sistema Tipos
    \draw[flecha] (tdoubleCtype.south) --
    node[left] {\small $\mbfone$} node[right]  {\small Registro}
    (typesystem.north);
    % Sistema tipos -> memoria
    \draw[flecha] (typesystem.east) --
    node[below]{\small Asignación de memoria}
    node[above]{\small $\mbftwo$}
    (memory.west);
    % Memoria -> Clase TDoubleClass (Tipo sistema)
    \draw[flecha] (memory.225) --
    node[above right, sloped]{\small $\mbfthree$}
    node[below right=0.2ex and -4ex, sloped]{\small Inicialización}
    (tdoubleclass.north);
    % Memoria -> Objeto TDouble (Tipo sistema)
    \draw[flecha] (memory.south) --
    node[left] {\small $\mbffour$}
    node[right] {\small Inicialización}
   (tdoubleobject.north);
   
   % Fondo amarillo
   \def\margen{16}
   \coordinate (limizda) at ($(typesystem.west)-(\margen pt, 0pt)$);
   \coordinate(limdcha) at ($(memory.east)+(\margen pt, 0pt)$);
   \coordinate(liminf) at ($(tdoubleobject.south)-(0pt, \margen pt)$);
   \coordinate(limsup) at ($(tdoubleCtype.north)+(0pt, \margen pt)$);
   \begin{scope}[on background layer]
     \node [background, fit= (liminf) (limsup) (limizda) (limdcha)] {};
   \end{scope}
 \end{tikzpicture}
 \caption{Proceso de registro del objeto \textsf{TDouble}.}
 \label{fig:proceso-registro}
\end{figure}

\subsection{Registro realizado sin macros}
Generalmente, el proceso de registro se lleva a cabo mediante unas macros, como
\texttt{G\_DECLARE\_FINAL\_TYPE} y \texttt{G\_DEFINE\_FINAL\_TYPE}, de manera que no
necesitamos preocuparnos por los detalles. Pero ahora es importante entender el
sistema de tipos de \textsf{GObject}, de manera que empezaremos analizando el proceso
de registro sin ayuda de macros.

Hay tres clases de tipos de \textsf{GObject}: fundamentales, estáticos y dinámicos.
Un tipo fundamental no deriva de ninguno más básico.
La clase de los tipos estáticos no se destruye cuando lo hacen todas sus instancias.
En cambio, la clase de los tipos dinámicos sí se destruye cuando se elimina la última instancia.

El tipo de \textsf{GObject}, y de todos los objetos que derivan de él, es estático.
La función que registra tipos estáticos es \texttt{g\_type\_register\_static}.
El código que se muestra a continuación se encuentra en el fichero '\textsf{gtype.h}' de
\textsf{GLib}:
\begin{lstlisting}[language=C]
GType
g_type_register_static (GType           parent_type,
                        const gchar     *type_name,
                        const GTypeInfo *info,
                        GTypeFlags      flags);
\end{lstlisting}

\newpage
Descripción de los parámetros implicados en el registro:
\begin{itemize}
  \tightlist
\item \texttt{parent\_type}: Es el tipo del padre.
\item \texttt{*type\_name}: Es el nombre del tipo que se va a registrar,
  por ejemplo, "\textsf{TDouble}".
\item \texttt{*info}: Es una estructura \texttt{GTypeInfo} que contiene información acerca
  del tipo que se va a registrar. Esta estructura se explica al terminar esta descripción.
\item \texttt{flags}: Si el tipo que se registra es abstracto o es un valor de tipo
  abstracto\footnotemark{} hay que especificarlo aquí. En caso contrario su valor es cero.
  \footnotetext{No veo clara la diferencia entre un tipo abstracto y un valor de tipo
    abstracto. Aunque pienso que, por ahora, no necesito profundizar más.}
\end{itemize}
Después del registro, la función \texttt{g\_type\_register\_static} retorna
el tipo del nuevo objeto. La definición de la estructura \texttt{GTypeInfo} es
\begin{lstlisting}[language=C]
typedef struct _GTypeInfo  GTypeInfo;
struct _GTypeInfo {
  /* interface types, classed types, instantiated types */
  guint16                class_size;

  GBaseInitFunc          base_init;
  GBaseFinalizeFunc      base_finalize;

  /* interface types, classed types, instantiated types */
  GClassInitFunc         class_init;
  GClassFinalizeFunc     class_finalize;
  gconstpointer          class_data;

  /* instantiated types */
  guint16                instance_size;
  guint16                n_preallocs;
  GInstanceInitFunc      instance_init;

  /* value handling */
  const GTypeValueTable  *value_table;
};
\end{lstlisting}

Esta estructura se debe crear antes del registro.

\begin{itemize}
  \tightlist
\item \texttt{class\_size}: Tamaño de la clase. Por ejemplo, el tamaño de la clase
  \textsf{TDouble} es "\texttt{sizeof (TDoubleClass)}''.
\item \texttt{base\_init}, \texttt{base\_finalize}: Estas funciones inicializan/finalizan
  los miembros dinámicos de la clase. En la mayoría de los casos no son necesarias y
  su valor es \texttt{NULL}.
  Para más información ver:
  \href{https://docs.gtk.org/gobject/callback.BaseInitFunc.html}
  {\textit{GObject API Reference -- BaseInitFunc}} y
  \href{https://docs.gtk.org/gobject/callback.ClassInitFunc.html}
  {\textit{GObject API Reference -- ClassInitFunc}}.
\item \texttt{class\_init}: Esta función inicializa los miembros estáticos de la clase. Asigna tu función de
  inicialización de la clase a esta función.
  Por convenio, el nombre es \textsf{<espacio-de-nombres>\_<nombre>\_class\_init}.
  Esta función hay que definirla y asignarla a este campo aunque no tenga código.
\item \texttt{class\_finalize}: Esta función finaliza la clase. Pero, como el tipo de los objetos derivados de
  \textsf{GObject} es estático, no se les asigna ninguna función de finalización. Por tanto a \textsf{TDouble}
  se le asigna \texttt{NULL} aquí.
\item \texttt{class\_data}: Datos que el usuario le pasa a las funciones de los dos métodos anteriores
  de inicialización y finalización de la clase. Normalmente se asigna \texttt{NULL}.
\item \texttt{instance\_size}: El tamaño de cada objeto que se instancia. Por ejemplo, el de una instancia
  de \textsf{TDouble} es "\texttt{sizeof (TDouble)}".
\item \texttt{n\_preallocs}: Este campo se debe ignorar porque se usaba en la antigua versión de \textsf{GLib}.
\item \texttt{instance\_init}: Inicializa los miembros de la instancia. Asigna tu función de inicialización a este
  método. Por convenio, el nombre es \textsf{<espacio-de-nombres>\_<nombre>\_init}. En nuestro caso, con
  el objeto \textsf{GObject}, el nombre sería \textsf{TObject\_init}.
  Esta función hay que definirla y asignarla a ese campo aunque no tenga código.
\item \texttt{*value\_table}:  Generalmente, este campo solo es útil para tipos fundamentales. Si el tipo deriva
  de \textsf{GObject}, se debe asignar \texttt{NULL}.
\end{itemize}
Esta información la almacena el sistema de tipos y se usa cuando se crea o destruye el objeto.
Los valores \texttt{class\_size} e \texttt{instance\_size} se usan para reservar memoria para la clase y la instancia,
respectivamente. Los métodos \texttt{class\_init} e \texttt{instance\_init} se ejecutan cuando se inicializan
la clase y la instancia, también respectivamente.

\subsubsection{Ejemplo 3}
El siguiente ejemplo muestra cómo utilizar la función \texttt{g\_type\_register\_static}.
En la práctica se utilizará una macro que realiza esta tarea automáticamente, pero aquí se realiza sin
la macro con fines didácticos.
Ver instrucciones para compilar los programas en la sección \ref{sec:compilacion}.

El listado es:
\begin{lstlisting}[language=C, numbers=left]
/*
 * ejemplo03.c
 * Prueba la función 'g_type_register_static'.
 */

#include <locale.h>
#include <glib-object.h>
 
 #define T_TYPE_DOUBLE  (t_double_get_type ())
 
 typedef struct _TDouble TDouble;
 struct _TDouble {
   GObject parent;
   double value;
 };
 
 typedef struct _TDoubleClass TDoubleClass;
 struct _TDoubleClass {
   GObjectClass parent_class;
 };
 
 static void
 t_double_class_init (TDoubleClass *class)
 {
 }
 
 static void
 t_double_init (TDouble *self)
 {
 }
 
 GType
 t_double_get_type (void)
 {
   static GType type = 0;
   GTypeInfo info;
 
   if (type == 0) {
     info.class_size = sizeof (TDoubleClass);
     info.base_init = NULL;
     info.base_finalize = NULL;
     info.class_init = (GClassInitFunc)  t_double_class_init;
     info.class_finalize = NULL;
     info.class_data = NULL;
     info.instance_size = sizeof (TDouble);
     info.n_preallocs = 0;
     info.instance_init = (GInstanceInitFunc)  t_double_init;
     info.value_table = NULL;
     type = g_type_register_static (G_TYPE_OBJECT, "TDouble", &info, 0);
   }
   
   return type;
 }
 
 int
 main (int argc, char **argv)
 {
   GType dtype;
   TDouble *d;

  // Para que g_print no transforme la codificación de caracteres
  // por su cuenta y no se vean los acentos.
  setlocale(LC_CTYPE, "");
   
  dtype = t_double_get_type (); /* equivale a  'dtype = T_TYPE_DOUBLE' */
  if (dtype) {
    g_print ("Registro correcto. El tipo es %lx.\n", dtype);
    } else {
      g_print ("Registro incorrecto.\n");
    }
 
  d = g_object_new (T_TYPE_DOUBLE, NULL);
  if (d) {
    g_print ("La instancia se ha creado correctamente. Su dirección es %p.\n", d);
  } else {
    g_print ("Error en la creación de la instancia.\n");
  }
  
  g_object_unref (d); /* Elimina el objeto 'd'. */
  
  return 0;
 }
 \end{lstlisting}

 \subsubsection{Salida del programa 'ejemplo03'}
\textsf{Registro correcto. El tipo es 0x563c801b24f0.}\par
\textsf{La instancia se ha creado correctamente Su dirección es 0x563c801b4000.}\par

\subsubsection{Comentarios}
\begin{itemize}
\item Línea 9:\par
  Se define la macro \texttt{T\_TYPE\_DOUBLE}, que se sustituye por la función
  \texttt{t\_double\_get\_type ()}. Esta función la definiremos más adelante porque vamos a llevar a cabo
  el proceso de registro de la clase \textsf{T\_Double\_Class} y del objeto \textsf{T\_Double} manualmente
  con fines didácticos,  pero esta definición normalmente se lleva a cabo automáticamente mediante macros.
  
  La primera vez que se llama a esta función, se ejecuta \texttt{g\_type\_register\_static}, que realiza el
  proceso de registro. En las siguientes llamadas a \texttt{t\_double\_get\_type} solo se devuelve el tipo de objeto.
  Todo esto se hará en las líneas 32--50.
  Ten en cuenta que normalmente, el sistema de tipos generará unas macros automáticamente que se encargarán
  de esta tarea. Estas macros serán las que debemos escribir en nuestro código.
\item Líneas 11--15:\par
  Se define el tipo C del objeto \textsf{TDouble} y la estructura que lo define \texttt{struct \_TDouble}.
\item Líneas 17--20:\par
  Se define el tipo C de la clase \textsf{TDoubleClass} y la estructura que lo define \texttt{struct \_TDoubleClass}.
\item Líneas 22--30:\par
  Se definen las funciones que inicializan la clase y la instancia. El argumento \texttt{class} es un puntero a
  la estructura de la clase y \texttt{self} apunta a la estructura de la instancia.
  Como se aprecia, no contienen ningún código ---en este caso---, pero son necesarias para el registro.
\item Líneas 32--53:\par
  Se define la función \texttt{t\_double\_get\_type}, a la que se hacía referencia en la línea 9.
  Esta función sustituye a la macro \texttt{T\_TYPE\_DOUBLE} y retorna el tipo del objeto \textsf{TDouble}
  que se registra mediante la función \texttt{g\_type\_register\_static}.
  Por convenio, el nombre es \textsf{<espacio-de-nombres>\_<nombre>\_get\_type}. Esta función reemplaza
  a la macro \textsf{\small <ESPACIO-DE-NOMBRES>\_TYPE\_<NOMBRE>} (todos los caracteres en mayúsculas).
  En su código se define una variable estática, \texttt{type}, para mantener el tipo del objeto que se define.
  Al ejecutarse por primera vez la función, se asigna el valor cero a la variable (\texttt{type = 0}).
  Después, se llama a g\_type\_register\_static para registrar el objeto en el sistema de tipos. En las subsecuentes
  llamadas, la función lo único que se hace es retornar el tipo que se definió en la primera ejecución.\par
  Cuando se utilicen las macros \texttt{G\_DECLARE\_FINAL\_TYPE} y \texttt{G\_DEFINE\_FINAL\_TYPE}, no será
  necesario definir la función esta función \passthrough{\lstinline!t\_double\_get\_type!}; de esto se encargarán las macros anteriores.
\item Líneas 39--49:\par
  Establece campos de la estructura \texttt{info} y llama a \texttt{g\_type\_register\_static}.
\item Líneas 55--82:\par
  La función principal. Asigna a la variable \texttt{dtype} el tipo de objeto \textsf{TDouble} y escribe el valor
  del tipo \text{TDouble}.
\item Líneas 58--59:\par
  Se define la variable \texttt{dtype}, que guardará el tipo del sistema de objeto \textsf{T\_DOUBLE}, y de la
  variable \texttt{d}, que es un puntero a la instancia de \textsf{T\_DOUBLE}, que se creará en la línea 65.
\item Línea 63:\par
  Se le asigna la cadena vacía a la variable de estado \texttt{LC\_CTYPE} para que la función
  \texttt{g\_print} no cambie el el sistema de caracteres del texto que imprimirá.
  Esto funcionará si la consola que se utiliza para ejecutar el programa utiliza el mismo sistema de caracteres
  que las cadenas (en este caso utilizamos UTF-8).
\item Líneas 65--70:\par
  Se guarda en la variable \texttt{dtype} el valor del tipo de objeto \textsf{T\_DOUBLE} y se muestra en la consola.
  También se podría haber sustituido esta línea por la equivalente, utilizando la macro de la línea 9:
  "\texttt{dtype = T\_TYPE\_DOUBLE}".
\item Líneas 72--77:\par
  Se crea una instancia \textsf{T\_DOUBLE} y se almacena en el puntero \texttt{d}. Se muestra en la consola su
  dirección. En la referencia de la API de \textsf{GObject} se dice que la función
  \texttt{g\_object\_new} returna un puntero a \textsf{GObject}, pero en realidad retorna un
  \texttt{gpointer}, que es lo mismo que \texttt{void *}, que puede asignarse a cualquier puntero, sea cual sea
  su tipo; en este caso, \texttt{d} se declaró como un puntero a \texttt{TDouble}, por lo que la línea
  "\texttt{d = g\_object\_new (T\_TYPE\_DOUBLE, NULL)}" es correcta. Nótese que si la función
  \texttt{g\_object\_new} retornara un puntero a \textsf{GObject}, sería necesario indicarlo:
  "\texttt{d = (gpointer) g\_object\_new (T\_TYPE\_DOUBLE, NULL)}".
\item Línea 79:\par
  Se elimina la instancia llamando a la función \texttt{g\_object\_unref}.
\end{itemize}

\subsection{Registro mediante la macro \texttt{G\_DEFINE\_TYPE}}
El proceso de registro descrito anteriormente se lleva a cabo siempre con el mismo algoritmo, por tanto,
el sistema define una macro, como \texttt{G\_DEFINE\_TYPE},  que lo lleva a cabo automáticamente
con solo invocarla.  Así, nos ahorramos definir manualmente la función \texttt{t\_double\_get\_type},
que es la que realizaba el registro llamando, a su vez,  a la función \texttt{g\_type\_register\_static}.

La macro \texttt{G\_DEFINE\_TYPE} hace lo siguiente:
\begin{itemize}
  \tightlist
\item Declara una función de inicialización de la clase. Su nombre es \textsf{<espacio-de-nombres>\_<nombre>\_class\_init}. Esto es una declaración, no una definición,
  por lo que necesitamos definirla más adelante.

  Por ejemplo, para el objeto \textsf{TDouble}, la función sería \texttt{t\_double\_class\_init}.
\item Declara una función de inicialización para las instancias. Su nombre es
  \textsf{<espacio-de-nombres>\_<nombre>\_init}.
  Esto es una declaración, no una definición, por lo que necesitamos definirla más adelante.

  Por ejemplo, para el objeto \textsf{TDouble}, la función sería \texttt{t\_double\_class\_init}.
\item Define una variable estática que apunta a la clase de la que deriva. Su nombre es
  \textsf{<espacio-de-nombres>\_<nombre>\_parent\_class}.
  
  Por ejemplo, para el objeto \textsf{TDouble}, la variable es \texttt{t\_double\_parent\_class}.
\item Define una función \textsf{<espacio-de-nombres>\_<nombre>\_get\_type ()}.
  
  Por ejemplo para el objeto \textsf{TDouble}, la función es \texttt{t\_double\_get\_type}.
  El registro se lleva a cabo como se hizo anteriormente.
\end{itemize}

Al usar esta macro se reduce el número de líneas de programa. En nuestro ejemplo, se sustituirían
las 22 líneas que van desde la 32 hasta la 53 del ejemplo 3, por una línea, que sería
\texttt{G\_DEFINE\_TYPE (TDouble, t\_double, G\_TYPE\_OBJECT)}.
El primer parámetro de la macro \texttt{G\_DEFINE\_TYPE} es el objeto que se define: en nuestro
caso \texttt{TDouble}. El segundo parámetro es el prefijo de las funciones que se utilizan para el
objeto: en nuestro caso \texttt{t\_double}. Por último, el nombre del objeto del que deriva:
\texttt{G\_TYPE\_OBJECT}.

En resumen, evitamos la definición de la función \texttt{t\_double\_get\_type}, pero seguimos
teniendo que definir la macro \texttt{T\_TYPE\_DOUBLE}, las estructuras \texttt{\_TDoubleClass} y
\texttt{\_TDouble} y los tipos de C asociados a las estructuras anteriores: \texttt{TDoubleClass}
y \texttt{TDouble}.
Todo esto se muestra, a continuación, en el ejemplo 4.

\subsubsection{Ejemplo 4}
Este ejemplo realiza lo mismo que el anterior, pero con menos líneas de código.
Gracias a \texttt{G\_DEFINE\_TYPE} no tenemos que escribir código como la variable \texttt{GTypeInfo info}
que  ejecutaba  expresamente la función  \passthrough{\lstinline!g\_type\_register\_static!}.
Es importante seguir las convención en el nombre de las funciones de inicialización.
A partir de \textsf{GLib 2.70} se puede utilizar la macro \texttt{G\_DEFINE\_FINAL\_TYPE} en lugar de
\texttt{G\_DEFINE\_TYPE}, para clases finales.
Ver instrucciones para compilar los programas en la sección \ref{sec:compilacion}.

El listado es:
\begin{lstlisting}[language=C, numbers=left]
/*
 * ejemplo04.c
 * Prueba la macro G_DEFINE_TYPE
 */

#include <locale.h>
#include <glib-object.h>

#define T_TYPE_DOUBLE  (t_double_get_type ())

typedef struct _TDouble TDouble;
struct _TDouble {
  GObject parent;
  double value;
};

typedef struct _TDoubleClass TDoubleClass;
struct _TDoubleClass {
  GObjectClass parent_class;
};

G_DEFINE_TYPE (TDouble, t_double, G_TYPE_OBJECT) /* o G_DEFINE_FINAL_TYPE (...) */

static void
t_double_class_init (TDoubleClass *class)
{
}

static void
t_double_init (TDouble *self)
{
}

int
main (int argc, char **argv)
{
  GType dtype;
  TDouble *d;

  // Para que g_print no transforme la codificación de caracteres
  // por su cuenta y no se vean los acentos.
  setlocale(LC_CTYPE, "");
  
  dtype = T_TYPE_DOUBLE; /* o dtype = t_double_get_type (); */
  if (dtype) {
    g_print ("Registro correcto. El tipo de objeto 'TDouble' es %lx.\n", dtype);
  } else {
    g_print ("Registro de 'TDouble' incorrecto.\n");
  }

  d = g_object_new (T_TYPE_DOUBLE, NULL);
  if (d) {
    g_print ("Instancia de 'TDouble' creada correctamente, su dirección es %p.\n", d);
  } else {
    g_print ("Error en la creación de la instancia 'TDouble'.\n");
  }

  g_object_unref (d); /* Elimina el objeto 'd'. */

  return 0;
}
\end{lstlisting}

 \subsubsection{Salida del programa 'ejemplo04'}
\textsf{Registro correcto. El tipo de objeto es 0x55e94aa2d4f0.}\par
\textsf{La instancia se ha creado correctamente Su dirección es 0x55e94aa2e000.}\par

\subsubsection{Comentarios}
\begin{itemize}
\item Línea 9:\par
  Se define la macro \texttt{T\_TYPE\_DOUBLE}, que se sustituye por la función
  \passthrough{\lstinline!t\_double\_get\_type!}, y se definirá automáticamente por el sistema cuando
  se llame a la macro en la línea 22, y registrará el nuevo tipo del sistema.
\item Líneas 11--15:\par
  Se define el tipo C del objeto \textsf{TDouble} y la estructura que lo define \texttt{struct \_TDouble}.
\item Líneas 17--20:\par
  Se define el tipo C de la clase \textsf{TDoubleClass} y la estructura que lo define \texttt{struct \_TDoubleClass}.
\item Línea 22:\par
  Se ejecuta la macro \texttt{G\_DEFINE\_TYPE}. El primer argumento es el nombre del objeto que se define,
  el segundo es \textsf{<espacio-de-nombres>\_<nombre>} en minúsculas, y el último es el objeto padre.
  En este ejemplo, los argumentos son: \texttt{TDouble}, \texttt{t\_double} y \texttt{G\_TYPE\_OBJECT}.
  A partir de \textsf{GLib 2.70} se puede utilizar la macro \texttt{G\_DEFINE\_FINAL\_TYPE} para clases finales.
\item Líneas 24--32:\par
  Se definen las funciones que inicializan la clase y la instancia. El argumento \texttt{class} es un puntero a la
  estructura de la clase y \texttt{self} apunta a la estructura de la instancia. Como se aprecia, no
  necesitan ningún código en este caso, pero son necesarias para el registro.
\item Líneas 34--60:\par
  La función principal. Asigna a la variable \texttt{dtype} el tipo de objeto \textsf{TDouble} y escribe el valor
  del tipo \text{TDouble}.
\item Líneas 37--38:\par
  Se define la variable \texttt{dtype}, que guardará el tipo del sistema de objeto \textsf{T\_DOUBLE}, y de la
  variable \texttt{d}, que es un puntero a la instancia de \textsf{T\_DOUBLE}, que se creará en la línea 47.
\item Línea 42:\par
  Se le asigna la cadena vacía a la variable de estado \texttt{LC\_CTYPE} para que la función
  \passthrough{\lstinline!g\_print!} no cambie el el sistema de caracteres del texto que imprimirá.
  Esto funcionará si la consola que se utiliza para ejecutar el programa utiliza el mismo sistema de caracteres
  que las cadenas (en este caso utilizamos UTF-8).
\item Líneas 44-49:\par
  Se guarda en la variable \texttt{dtype} el valor del tipo de objeto \textsf{T\_DOUBLE} y se muestra en la consola.
  También se podría haber sustituido esta línea por la equivalente, utilizando la macro de la línea 9:
  "\texttt{dtype = t\_double\_get\_type ();}".
\item Líneas 51--56:\par
  Se crea una instancia \textsf{T\_DOUBLE} y se almacena en el puntero \texttt{d}. Se muestra en la consola su
  dirección. En la referencia de la API de \textsf{GObject} se dice que la función
  \passthrough{\lstinline!g\_object\_new!} returna un puntero a \textsf{GObject}, pero en realidad retorna un
  \texttt{gpointer}, que es lo mismo que \texttt{void *}, que puede asignarse a cualquier puntero, sea cual sea
  su tipo; en este caso, \texttt{d} se declaró como un puntero a \texttt{TDouble}, por lo que la línea
  "\texttt{d = g\_object\_new (T\_TYPE\_DOUBLE, NULL)}" es correcta. Nótese que si la función
  \passthrough{\lstinline!g\_object\_new!} retornara un puntero a \textsf{GObject}, sería necesario indicarlo:
  "\texttt{d = (gpointer) g\_object\_new (T\_TYPE\_DOUBLE, NULL)}".
\item Línea 58:\par
  Se elimina la instancia llamando a la función \passthrough{\lstinline!g\_object\_unref!}.
\end{itemize}

\subsection{La macro \texttt{G\_DECLARE\_FINAL\_TYPE}}
Otra macro útil es \texttt{G\_DECLARE\_FINAL\_TYPE}, que se puede usar para objetos de tipo final.
Los tipos finales no tienen hijos, esto es, no se pueden derivar objetos a partir de ellos.
Los tipos derivables permiten definir objetos hijos y se declaran mediante \texttt{G\_DECLARE\_DERIVABLE\_TYPE}. En todo caso, muy a menudo se declararán  objetos finales.

La macro \texttt{G\_DECLARE\_FINAL\_TYPE} hace lo siguiente:
\begin{itemize}
  \tightlist
\item Declara la función \texttt{<espacio-de-nombres>\_<nombre>\_get\_type}. Esta es solo una declaración,
  Nosotros deberíamos definirla, pero usando la macro \texttt{G\_DEFINE\_TYPE}, se define la función
  automáticamente. Así, en realidad, no necesitamos escribir la definición de la función.
\item El tipo C del objeto se define aplicando \texttt{typedef} a una estructura. Por ejemplo, para el objeto
  \textsf{TDouble}, entonces se define el tipo C \texttt{TDouble}, mediante el comando
  \texttt{typedef struct \_TDouble TDouble}, aunque tendremos que definir la estructura \texttt{struct \_TDouble}
  antes de utilizar \texttt{G\_DEFINE\_...\_TYPE}.
\item Se define la macro \texttt{<ESPACIO-DE-NOMBRES>\_<NOMBRE>}. Por ejemplo, para el objeto
  \textsf{TDouble}, la macro será \texttt{T\_DOUBLE}, que se expandirá a una función que ajusta el argumento
  a un puntero al objeto. Por ejemplo, \texttt{T\_DOUBLE(obj)} ajusta el tipo de puntero a objeto a
  \texttt{TDouble *}.
\item Se define la macro \texttt{<ESPACIO-DE-NOMBRES>\_IS\_<NOMBRE>}. Por ejemplo, para el objeto
  \textsf{TDouble}, la macro será \texttt{T\_IS\_DOUBLE}. Cuando se ejecuta, se expande a una función que
  comprueba si el argumento es un puntero a una instancia de \textsf{TDouble}. Retorna 'true' si el argumento
  apunta a un objeto que deriva de \textsf{TDouble}.
\item Se define la estructura de la clase. Una clase final no necesita tener miembros en la estructura de la clase,
  con excepción de la clase padre. La definición es como la de las líneas 17 a 20 del código de  ejemplo04.c.
\end{itemize}

El primer parámetro de la macro \texttt{G\_DECLARE\_TYPE} es el objeto que se define: en nuestro
caso \texttt{TDouble}. El segundo es el prefijo de las funciones que se utilizan para el objeto: en nuestro
caso \texttt{t\_double}. El tercero es el espacio de nombres de el tipo que se declara, en este caso es
\texttt{T}. El cuarto es el nombre del tipo: \texttt{DOUBLE}, y por último el objeto padre: \texttt{GObject}.

Se debe escribir la macro que define el tipo de objeto, antes de que se llame a
\texttt{G\_DECLARE\_FINAL\_TYPE}. Por ejemplo, para el objeto \textsf{TDouble}, hay que escribir
\texttt{\#define T\_TYPE\_DOUBLE (t\_double\_get\_type ())} antes que \texttt{G\_DECLARE\_FINAL\_TYPE}.

\subsubsection{Ejemplo 5}
En este ejemplo se utilizan las macros \texttt{G\_DECLARE\_FINAL\_TYPE} y
\texttt{G\_DEFINE\_FINAL\_TYPE}, que ayudan a declarar, definir e identificar los objetos finales que
derivan de \textsf{GObject}. La segunda la analizamos en el ejemplo anterior.
La macro \texttt{G\_DECLARE\_FINAL\_TYPE}, ejecutada justo después de definir \texttt{T\_TYPE\_DOUBLE},
permite ahorrarnos la definición de la estructura \texttt{\_TDoubleClass} y las definiciones de los
tipos C \texttt{TDoubleClass} y \texttt{TDouble}. Aún así, se tiene que definir la estructura \texttt{\_TDouble},
para incluir los parámetros que tendrán los nuevos objetos. Además, define la macro \texttt{T\_IS\_DOUBLE}
para poder comprobar que el tipo de un objeto es \textsf{TDouble}.

En este ejemplo tendremos  que seguir este orden para registrar el nuevo tipo del sistema \textsf{TDouble}:
\begin{itemize}
  \tightlist
\item definir la macro \texttt{T\_TYPE\_DOUBLE}.
\item ejecutar la macro \texttt{G\_DECLARE\_FINAL\_TYPE}.
\item definir la estructura \texttt{TDouble}, con los parámetros que necesiten los nuevos objetos.
\item ejecutar la macro \texttt{G\_DEFINE\_FINAL\_TYPE}.
\item definir las funciones de inicialización \texttt{t\_double\_class\_init} y \texttt{t\_double\_init}.
\end{itemize}
Por ahora, no necesitamos más, aunque poco a poco iremos completando la funcionalidad
de este tipo 'TDouble', en particular, y de los nuevos tipos de objetos, en general.
Ver instrucciones para compilar los programas en la sección \ref{sec:compilacion}.

El listado es:
\begin{lstlisting}[language=C, numbers=left]
/*
 * ejemplo05.c
 * Prueba las macros G_DECLARE_FINAL_TYPE y G_DEFINE_FINAL_TYPE
 */

#include <locale.h>
#include <glib-object.h>
 
#define T_TYPE_DOUBLE  (t_double_get_type ())
G_DECLARE_FINAL_TYPE (TDouble, t_double, T, DOUBLE, GObject)
 
struct _TDouble {
  GObject parent;
  double value;
};
 
G_DEFINE_TYPE (TDouble, t_double, G_TYPE_OBJECT)
 
static void
t_double_class_init (TDoubleClass *class)
{
}
 
 static void
 t_double_init (TDouble *self)
 {
 }
 
int
main (int argc, char **argv)
{
  GType dtype;
  TDouble *d;

  // Para que g_print no transforme la codificación de caracteres
  // por su cuenta y no se vean los acentos.
  setlocale(LC_CTYPE, "");
  
  dtype = T_TYPE_DOUBLE; /* o dtype = t_double_get_type (); */
  if (dtype) {
    g_print ("Registro correcto. El tipo de objeto es %lx.\n", dtype);
  } else {
    g_print ("Registro incorrecto.\n");
  }
 
  d = g_object_new (T_TYPE_DOUBLE, NULL);
  if (d) {
    g_print ("La instancia se ha creado correctamente. Su dirección es %p.\n", d);
  } else {
    g_print ("Error en la creación de la instancia.\n");
  }
 
  if (T_IS_DOUBLE (d)) {
    g_print ("La variable 'd' es una instancia de TDouble.\n");
  } else {
    g_print ("La variable 'd' no es una instancia de TDouble.\n");
  }
 
  if (G_IS_OBJECT (d)) {
    g_print ("La variable 'd' es una instancia de GObject.\n");
  } else {
    g_print ("La variable 'd' no es una instancia de GObject.\n");
  }
  
  g_object_unref (d);
 
  return 0;
 }
\end{lstlisting}

 \subsubsection{Salida del programa 'ejemplo05'}
\textsf{Registro correcto. El tipo de objeto es 0x559b2af2c4f0.}\par
\textsf{La instancia se ha creado correctamente Su dirección es 0x559b2af2d000.}\par
\textsf{La variable 'd' es una instancia de TDouble.}\par
\textsf{La variable 'd' es una instancia de GObject.}\par

\subsubsection{Comentarios}
\begin{itemize}
\item Líneas 9--10:\par
  Se define la macro \texttt{T\_TYPE\_DOUBLE}, que se expandirá a la función
  \passthrough{\lstinline!t\_double\_get\_type!} y, después se declara el tipo \textsf{TDouble} por medio
  de la macro \texttt{G\_DECLARE\_FINAL\_TYPE}, en ese orden.
\item Líneas 12--15:\par
  Se define la estructura \texttt{struct \_TDouble}. Ya no es necesario definir el tipo C \texttt{TDouble} mediante
  \texttt{typedef}; se realiza automáticamente en la línea 17.
\item Línea 17:\par
  Se expande la macro \texttt{G\_DEFINE\_TYPE} que realiza la definición del tipo C de la clase
  \textsf{TDoubleClass} y del objeto \textsf{TDouble}.
  El primer argumento es el nombre del objeto que se define,   el segundo es \textsf{<espacio-de-nombres>\_<nombre>} en minúsculas, que será el prefijo de las funciones de esa clase,
  y el último es el objeto padre.
  En este ejemplo, los argumentos son: \texttt{TDouble}, \texttt{t\_double} y \texttt{G\_TYPE\_OBJECT}.
  A partir de \textsf{GLib 2.70} se puede utilizar la macro \texttt{G\_DEFINE\_FINAL\_TYPE} para clases finales.
\item Líneas 19--27:\par
  Se definen las funciones que inicializan la clase y la instancia. El argumento \texttt{class} es un puntero a la
  estructura de la clase y \texttt{self} apunta a la estructura de la instancia. Como se aprecia, no
  necesitan ningún código en este caso, pero son necesarias para el registro.
\item Líneas 29--68:\par
  La función principal. Asigna a la variable \texttt{dtype} el tipo de objeto \textsf{TDouble} y escribe el valor
  del tipo \text{TDouble}. Además, comprueba que la instancia creada es un objeto que deriva, tanto de
  \textsf{TDouble}, como de \textsf{GObject}.
\end{itemize}

\section{Uso básico de parámetros de un objeto}
En esta sección veremos cómo asignar valores  a los parámetros de un objeto cómo acceder a los mismos,
posteriormente. Para ello, definiremos un método para crear la instancia de un objeto \texttt{TDouble}
con un valor concreto, y métodos para recuperar (\emph{getter}) y asignar (\emph{setter}, que se
encargarán de estas tareas.
Además, se crearán dos ficheros extra, uno de cabecera y otro de definiciones, para el objeto.
\subsection{Ejemplo 6}
Se estructura un programa que usa objetos \textsf{TDouble}, en ficheros individuales \textsf{tdouble.h},
\textsf{tdouble.c} y \textsf{main.c}.
El objeto \textsf{TDouble} se declara y define en los dos primeros ficheros, respectivamente.
Ver instrucciones para compilar los programas en la sección \ref{sec:compilacion}.

\subsubsection{Declaración del objeto \textsf{TDouble}: fichero de cabecera \textsf{tdouble.h}}

\begin{lstlisting}[language=C, numbers=left]
/*
 * tdouble.h
 * Declaración del objeto TDouble.
 */

#ifndef T_DOUBLE_H
#define T_DOUBLE_H
 
#include <glib-object.h>
 
#define T_TYPE_DOUBLE  (t_double_get_type ())
G_DECLARE_FINAL_TYPE (TDouble, t_double, T, DOUBLE, GObject)
 
gboolean
t_double_get_value (TDouble *self, double *value);
 
void
t_double_set_value (TDouble *self, double value);
 
TDouble *
t_double_new (double value);

#endif /* T_DOUBLE_H */
\end{lstlisting}

\subsubsection{Comentarios}
\begin{itemize}
\item Este fichero de cabecera incluye macros, que proporcionan información sobre el tipo, conversión de
  tipo de puntero (\textit{cast}), comprobación del tipo de objeto y funciones públicas.
\item Línea 6--7, 23:\par
  Se añaden estas líneas para garantizar que este fichero solo se lee una vez.
\item Líneas 11--12:\par
  Se declara la macro \texttt{T\_TYPE\_DOUBLE} que se expandirá a \texttt{t\_double\_get\_type ()}.
  Se declara el tipo de objeto \textsf{TObject}, mediante la macro\texttt{G\_DECLARE\_FINAL\_TYPE}
  a la que se añaden los argumentos: \texttt{TDouble}, \texttt{t\_double} y \texttt{GObject}.
\item Líneas 14--18:\par
  Se declaran las funciones públicas. La primera retorna el valor del objeto \textsf{TDouble} y la
  segunda lo cambia.
\item Líneas 20--21:\par
  Se declara la función que crea instancias de \textsf{TDouble}.
\end{itemize}

\subsubsection{Definición del objeto \textsf{TDouble}: fichero \textsf{tdouble.c}}

\begin{lstlisting}[language=C, numbers=left]
/*
 * tdouble.c
 * Definición del objeto TDouble.
 */
 
#include "tdouble.h"

struct _TDouble {
  GObject parent;
  double value;
};

G_DEFINE_TYPE (TDouble, t_double, G_TYPE_OBJECT)

static void
t_double_class_init (TDoubleClass *class) {}

static void
t_double_init (TDouble *self) {}

gboolean
t_double_get_value (TDouble *self, double *value)
{
  g_return_val_if_fail (T_IS_DOUBLE (self), FALSE);

  *value = self->value;
  
  return TRUE;
}

void
t_double_set_value (TDouble *self, double value)
{
  g_return_if_fail (T_IS_DOUBLE (self));

  self->value = value;
}

TDouble *
t_double_new (double value)
{
  TDouble *d;

  d = g_object_new (T_TYPE_DOUBLE, NULL);
  d->value = value;
  
  return d;
}
 \end{lstlisting}

\subsubsection{Comentarios}
\begin{itemize}
\item Líneas 8--11:\par
  Estructura de los objetos \textsf{TDouble}. Se debe llamar \texttt{\_TDouble} porque  la macro 
  \texttt{G\_DECLARE\_FINAL\_TYPE} en el fichero de cabecera, que define el tipo C
  \texttt{TDouble} (\texttt{typedef struct \_TDouble}), necesita ese nombre.
  \par
  Al definir la estructura en este fichero (\textsf{tdouble.c}), se impide asignar el valor del parámetro
  \texttt{value} de la misma en cualquier fichero que no sea este, mediante el código
  \texttt{obj->value = 10.0}, por ejemplo, o leer su valor mediante un código del estilo de
  \texttt{double var = obj->value}. En su lugar, para asignar valores, se hará mediante el constructor
  \texttt{t\_double\_new (10.0)}, por ejemplo, o mediante la función \emph{setter},
  \texttt{t\_double\_set\_value (obj, 10.0)}, y para leer valores, se utilizará la función \emph{getter}
  \texttt{t\_double\_get\_value (obj, \&var)}, donde \texttt{var} es una variable de tipo \texttt{double}.
  Estas funciones comprueban que \texttt{obj} sea una instancia de \textsf{TDouble}.
  \par
  Si hubiéramos querido utilizar \texttt{obj->value}, deberíamos haber definido la estructura en el
  fichero de cabecera \textsf{tdouble.h}. Pero si este hubiera sido nuestro interés, nos debería
  haber bastado definir la estructura, sin necesidad de introducir un nuevo tipo de objetos.
\item Línea 13:\par
  Se expande la macro que define y  el objeto \textsf{TDouble} y su registro.
\item Líneas 15--23:\par
  Se definen las funciones de inicialización de la clase y de las instancias. No hacen nada, por ahora.
\item Líneas 25--33:\par
  Definición de la función \textit{getter}. El argumento \texttt{value} es un puntero a una variable de tipo C
  \texttt{double}. Asigna el valor del objeto \texttt{self->value} a la variable. Si no hay error retorna \texttt{TRUE}.
  La función \passthrough{\lstinline!g\_return\_val\_if\_fail!} se utiliza para comprobar el tipo de objeto que
  se le pasa como argumento. Si no es de tipo \textsf{TDouble}, envía un mensaje de error al fichero
  de registro de errores, advertencias y mensajes (fichero \textit{log}), e inmediatamente retorna \texttt{FALSE}.
  Este registro sirve para informar al programador del error, pero no se debe utilizar para informar del
  mismo al usuario. Para más información, ver \href{https://docs.gtk.org/glib/error-reporting.html}
  {\textit{error reporting}} en la API de referencia de Glib.
  {\color{red}
  La función \passthrough{\lstinline!g\_return\_val\_if\_fail!} no se usa en funciones de clase estáticas, que son
  privadas, porque las funciones estáticas se ejecutan solo desde funciones que están en el mismo fichero y estas
  conocen el tipo de los parámetros\footnotemark{}.}
  \footnotetext{Debo esforzarme en traducir mejor esta última oración y entenderla (las dos cosas).
    Me está queriendo informar de algo que no termino de captar: Sé lo que es una función estática, pero
  se ve que me estoy perdiendo algún detalle.}
\item Líneas 35--41:\par
  Definición de la función \textit{setter}. La función \passthrough{\lstinline!g\_return\_if\_fail!} se usa
  para comprobar el objeto que se pasa como argumento. Esta función no retorna ningún valor, porque
  el tipo de \texttt{t\_double\_set\_value} es \texttt{void}. Por tanto, usamos esa función, en lugar de
  \passthrough{\lstinline!g\_return\_val\_if\_fail!}.
\item Líneas 43--52:\par
  Definición de la función que instancia objetos. Tiene un parámetro, que es el valor del objeto.
\item Línea 48:\par
  Esta función usa \passthrough{\lstinline!g\_object\_new!} para instanciar un objeto. El argumento
  \texttt{T\_TYPE\_DOUBLE} se expande a la función \passthrough{\lstinline!t\_double\_get\_type ()!}.
  Cuando esta función se llama por primera vez, se lleva a cabo el proceso de registro de \textsf{TObject}.
\end{itemize}

\subsubsection{Prueba de \textsf{TDouble}: fichero \textsf{main.c}}

\begin{lstlisting}[language=C, numbers=left]
/*
 * main.c
 * Se prueba el objeto TDouble.
 */

#include <locale.h>
#include "tdouble.h"

int
main (int argc, char **argv)
{
  TDouble *d;
  double value;

  // Para que g_print no transforme la codificación de caracteres
  // por su cuenta y no se vean los acentos.
  setlocale(LC_CTYPE, "");

  d = t_double_new (10.0);
  if (t_double_get_value (d, &value)) {
    g_print ("t_double_get_value succesfully assigned %lf to value.\n", value);
  } else {
    g_print ("t_double_get_value failed.\n");
  }

  t_double_set_value (d, -20.0);
  g_print ("Now, set d (tDouble object) with %lf.\n", -20.0);
  
  if (t_double_get_value (d, &value)) {
    g_print ("t_double_get_value succesfully assigned %lf to value.\n", value);
  } else {
    g_print ("t_double_get_value failed.\n");
  }
  
  g_object_unref (d);

  return 0;
}
\end{lstlisting}

\subsubsection{Comentarios}
\begin{itemize}
\item Línea 7:\par
  Es necesaria para acceder a \textsf{TDouble}.
\item Líneas 12--13:\par
  Se declara un puntero \texttt{d} al tipo de objeto \texttt{TDouble} y una variable \texttt{value} de tipo C,
  \texttt{double}.
\item Línea 17:\par
  Se utiliza para que la función \texttt{g\_print} no modifique la codificación de caracteres. Esto se hace
  para que se puedan ver las tildes que imprime.
\item Línea 19:\par
  Se instancia un objeto \textsf{TDouble} y se hace que \texttt{d} apunte al objeto.
\item Líneas 20--24:\par
  Se prueba la función \textit{getter} del objeto.
\item Línea 26:\par
  Se prueba la función \textit{setter} del objeto, cambiando el valor de la instancia \texttt{d}.
\item Líneas 29--33:\par
  Se vuelve a probar la función \textit{getter}, para comprobar que cambió el valor de la instancia \texttt{d}.
\item Línea 35:\par
  Se libera la instancia \texttt{d}.
\end{itemize}

\section{Uso básico de métodos de instancias}
Las funciones de objetos están abiertas a otros objetos. Son como los métodos públicos en los lenguajes
orientados a objetos.
En realidad se llaman métodos de instancia (\emph{instance methods}) en la Referencia de la API de GObject.

Es natural añadir operadores de cálculo a los objetos \textsf{TDouble} porque estos representan números
reales. Por ejemplo, \texttt{t\_double\_add} puede sumar el valor de dos instancias de \textsf{TDouble}
pasadas como argumentos y, como resultado, crea otra instancia del mismo tipo que tiene el valor de la
suma de ambas. Véase  el siguiente código
\begin{lstlisting}[language=C, numbers=left]
TDouble *
t_double_add (TDouble *self, TDouble *other) {
  g_return_val_if_fail (T_IS_DOUBLE (self), NULL);
  g_return_val_if_fail (T_IS_DOUBLE (other), NULL);
  double value;

  if (! t_double_get_value (other, &value))
    return NULL;
  return t_double_new (self->value + value);
}
\end{lstlisting}
El primer argumento, \texttt{self} es la instancia a la que pertenece la función. El segundo argumento es otra
instancia de \textsf{TDouble}. Como resultado, la función retorna otra instancia de \textsf{TDouble}, cuyo
parámetro \textsf{value} es la suma de los parámetros \textsf{value} de los argumentos.

El valor de \texttt{self} se accede mediante \texttt{self->value}, pero no se puede usar \texttt{other->value}
para la instancia \texttt{other}; en su lugar, hay que utilizar la función \texttt{t\_double\_get\_value}.
Obsérvese que la instancia \texttt{self}, puede acceder a su parámetro mediante \texttt{self->value},
pero para acceder al parámetro de otra instancia, necesita utilizar la función pública de esa otra
instancia \texttt{t\_double\_get\_value}. Así, cuando un objeto A accede a otro B, A debe utilizar una
función pública de B.

\subsection{Aplicación de métodos de instancia con \textsf{TDouble}: Programa 'operaciones'}
Aquí se va a presentar un ejemplo en el que se utilizan métodos de instancia para realizar operaciones
aritméticas básicas: suma, resta, multiplicación, división y cambio de signo, con los valores de los
parámetros de instancias de \textsf{TDouble}.

La aplicación se estructura en tres ficheros, \textsf{tdouble.h}, \textsf{tdouble.c} y \textsf{main.c}.
Por brevedad, se explicará el código nuevo que no se haya comentado ya en el ejemplo 6.
Ver instrucciones para compilar los programas en la sección \ref{sec:compilacion}.

\subsubsection{Declaración del tipo \textsf{TDouble}: fichero de cabecera \textsf{tdouble.h}}
El primero es el fichero de cabecera que declara el tipo \textsf{TDoble}, el parámetro \texttt{value} y
los métodos asociados. Aquí, el código nuevo es el de declaración de los métodos relacionados con las
operaciones aritméticas en las líneas 22--26.

\begin{lstlisting}[language=C, numbers=left]
/*
 * tdouble.h
 * Declaración del tipo TDouble.
 */

 #ifndef TDOUBLE_H
#define TDOUBLE_H

#include <glib-object.h>

#define T_TYPE_DOUBLE (t_double_get_type ())
G_DECLARE_FINAL_TYPE (TDouble, t_double, T, DOUBLE, GObject);

gboolean
t_double_get_value (TDouble *self, double *value);

void
t_double_set_value (TDouble *self, double value);

TDouble * t_double_new (double value);

TDouble *t_double_add (TDouble *self, TDouble *other);
TDouble *t_double_sub (TDouble *self, TDouble *other);
TDouble *t_double_mul (TDouble *self, TDouble *other);
TDouble *t_double_div (TDouble *self, TDouble *other);
TDouble *t_double_uminus (TDouble *self);

#endif /* T_DOUBLE_H */
\end{lstlisting}

\subsubsection{Definición del tipo \textsf{TDouble}: fichero \textsf{tdouble.c}}
En ese fichero se define el tipo \textsf{TDoble}, se añade el parámetro asociado \texttt{double value},
y se definen las funciones aritméticas, estas últimas en las líneas 45--102. La lógica de estas se expuso al
principio de esta sección.

\begin{lstlisting}[language=C, numbers=left]
/*
 * tdouble.c
 * Definición del tipo TDouble.
 */

#include "tdouble.h"

struct _TDouble {
  GObject parent;
  double value;
};

G_DEFINE_FINAL_TYPE (TDouble, t_double, G_TYPE_OBJECT);

static void
t_double_class_init (TDoubleClass *class) {};

static void
t_double_init (TDouble *self) {};

gboolean
t_double_get_value (TDouble *self, double *value)
{
  g_return_val_if_fail (T_IS_DOUBLE (self), FALSE);
  *value = self->value;
  return TRUE;
}

void
t_double_set_value (TDouble *self, double value)
{
  g_return_if_fail (T_IS_DOUBLE (self));
  self->value = value;
}

TDouble *
t_double_new (double value)
{
  TDouble *obj;
  obj = g_object_new (T_TYPE_DOUBLE, NULL);
  obj->value = value;
  return obj;
}

TDouble *
t_double_add (TDouble *self, TDouble *other)
{
  double value;
  
  g_return_val_if_fail (T_IS_DOUBLE (self), NULL);
  g_return_val_if_fail (T_IS_DOUBLE (other), NULL);
  if (! t_double_get_value (other, &value)) {
    return NULL;
  }

  return t_double_new (self->value + value);
}

TDouble *
t_double_sub (TDouble *self, TDouble *other)
{
  double value;
  
  g_return_val_if_fail (T_IS_DOUBLE (self), NULL);
  g_return_val_if_fail (T_IS_DOUBLE (other), NULL);
  if (! t_double_get_value (other, &value)) {
    return NULL;
  }
  return t_double_new (self->value - value);
}

TDouble *
t_double_mul (TDouble *self, TDouble *other)
{
  double value;
  
  g_return_val_if_fail (T_IS_DOUBLE (self), NULL);
  g_return_val_if_fail (T_IS_DOUBLE (other), NULL);
  if (! t_double_get_value (other, &value)) {
    return NULL;
  }
  return t_double_new (self->value * value);
}

TDouble *
t_double_div (TDouble *self, TDouble *other)
{
  double value;
  g_return_val_if_fail (T_IS_DOUBLE (self), NULL);
  g_return_val_if_fail (T_IS_DOUBLE (other), NULL);
  if ((! t_double_get_value (other, &value)) || value == 0.0) {
    return NULL;
  }
  return t_double_new (self->value / value);
}

TDouble *
t_double_uminus (TDouble *self)
{
  g_return_val_if_fail (T_IS_DOUBLE (self), NULL);
  return t_double_new (-self->value);
}
\end{lstlisting}

\subsubsection{Aplicación utlilizando el tipo \textsf{TDouble}: fichero \textsf{main.c}}
Este fichero utiliza el tipo \textsf{TDoble} para probar los métodos de instancia que realizan operaciones
aritméticas básicas.

\begin{lstlisting}[language=C, numbers=left]
/*
 * main.c
 * Prueba de operaciones aritméticas con el valor de instancias TDouble.
 */

#include <stdlib.h>
#include <locale.h>

#include "tdouble.h"

void print_val (TDouble *obj, char *str)
{
  double value;
  
  if (t_double_get_value(obj, &value)) {
    g_print ("'%s': %3.6f\n", str, value);
  } else {
    g_print ("Error, la instancia '%s' no tiene valor.\n", str);
    exit (1);
  }
}

int
main (void)
{
  TDouble *obj1, *obj2, *obj3;
  double value;
  const double val1 = 24.0;
  const double val2 = 14.0;
  double val3;

  setlocale (LC_CTYPE, "");

  g_print("-------------------------\n");
  
    /* Se crea la instancia de TDouble, 'obj1' */
  obj1 = t_double_new (val1);
  if (!t_double_get_value(obj1, &value)) {
    g_print ("Error, no se ha podido crear la instancia 'obj1'.\n");
    exit (1);
  }
  print_val (obj1, "obj1");
  
  /* Se crea la instancia de TDouble, 'obj2' */
  obj2 = t_double_new (val2);
  if (!t_double_get_value(obj2, &value)) {
    g_print ("Error, no se ha podido crear la instancia 'obj2'.\n");
    exit (1);
  }
  print_val (obj2, "obj2");

  g_print("-------------------------\n");
    
  /* Suma */
  obj3 = t_double_add (obj1, obj2);
  print_val (obj3, "obj1 + obj2");

    /* Resta */
    obj3 = t_double_sub (obj1, obj2);
  print_val (obj3, "obj1 - obj2");

  /* Multiplicación */
    obj3 = t_double_mul (obj1, obj2);
    print_val (obj3, "obj1 * obj2");

  /* División */
  obj3 = t_double_div (obj1, obj2);
  print_val (obj3, "obj1 / obj2");

  /* Cambio de signo */
    obj3 = t_double_uminus (obj1);
    print_val (obj3, "-obj1");    

  g_object_unref (obj1);
  g_object_unref(obj2);
  g_object_unref(obj3);

  g_print("-------------------------\n");
    
  g_print ("OK!\n");

  return EXIT_SUCCESS;
}
\end{lstlisting}

\subsubsection{Salida del programa 'operaciones'}
\textsf{-------------------------}\par
\textsf{'obj1': 24.000000}\par
\textsf{'obj2': 14.000000}\par
\textsf{-------------------------}\par
\textsf{'obj1 + obj2': 38.000000}\par
\textsf{'obj1 - obj2': 10.000000}\par
\textsf{'obj1 * obj2': 336.000000}\par
\textsf{'obj1 / obj2': 1.714286}\par
\textsf{'-obj1': -24.000000}\par
\textsf{-------------------------}\par
\textsf{OK!}




  
%%% Local Variables:
%%% coding: utf-8
%%% mode: latex
%%% TeX-engine: luatex
%%% TeX-master: "../GObject_tutorial_es.tex"
%%% End:

% LaTeX-command: "lualatex --shell-escape"
