x% registro.tex
%
% Copyright (C) 2024 José A. Navarro Ramón <janr.devel@gmail.com>
% 1) Código LuaLatex:
%    Licencia GPL-2.
% 2) Producto en pdf, postscript, etc.:
%    Licencia Creative Commons Recognition Share alike. (CC-BY-SA)

\section{Sistema de tipos y registro de clases}
\subsection{Sistema de tipos} \label{subsec:sistematipos}
\subsubsection{Introducción}
\textsf{GObject} es un objeto básico. Es muy simple y no se puede hacer mucho con él, excepto crear
clases derivadas e instanciar nuevos tipos de objetos.
En realidad esta es la característica más importante de \textsf{GObject}.
Aquí se describe como definir clases derivadas de \textsf{GObject}.

En esta sección se crearán objetos que representan números reales. Este ejemplo no será muy útil, porque
el lenguaje C ya tiene un tipo \emph{double} que representa números reales. Sin embargo, será útil para
conocer la técnica para definir clases y objetos derivados de \textsf{GObject}.

\subsubsection{Convenio de nombres}
Primero se debe conocer el convenio de nombres que se usará. El nombre de un objeto tiene dos partes:
\begin{enumerate}
  \tightlist
\item Un \href{https://es.wikipedia.org/wiki/Espacio_de_nombres}{espacio de nombres}
  (\href{https://en.wikipedia.org/wiki/Namespace}{\textit{namespace}}).
\item Un nombre propiamente dicho, que se considera incluido en el espacio de nombres.
\end{enumerate}

Por ejemplo, \textsf{GObject} consiste en un espacio de nombres ``\textsf{G}'' y un nombre ``\textsf{Object}''.
\textsf{GtkWidget} tiene un espacio de nombres ``\textsf{Gtk}'' y el nombre ``\textsf{Widget}''.
Para el objeto de números reales que pondremos como ejemplo, se decide poner ``\textsf{T}'' como espacio
de nombres y ``\textsf{Doble}'' como nombre. Así, estos objetos se identificarán como \textsf{TDoble}.
Además serán objetos que derivan de \textsf{GObject}, representan números reales y el tipo del número
será \textit{double}.

\begin{figure}[ht]
  \centering
  \def\scl{1}
  \begin{tikzpicture}[%
    scale=\scl,
    every node/.style={font=\LARGE\sffamily, minimum size= 8ex},
     background/.style={
      line width=\bgborderwidth,
      draw=\bgbordercolor,
      fill=\bgcolor,
    },
   ]
   % COORDENADAS
   % - 
   % DIBUJO
   % Convenio de nombres de objetos
   \node[draw] (namespace)
   {\begin{tabular}{c} \textcolor{gray}{Espacio de nombres} \\ T \end{tabular}};
   \node [draw, right=1em of namespace] (name)
   {\begin{tabular}{c} \textcolor{gray}{Nombre} \\ Doble \end{tabular}};
   \node [right=1em of name] (tdoble) {$\equiv$ TDoble}; 
   % Fondo amarillo
   \def\margensup{18}
   \def\margeninf{12}
   \def\margenlateralizdo{18}
   \def\margenlateraldcho{12}
   \coordinate (limsupdcha) at ($(tdoble.north east)+(\margenlateraldcho pt, \margensup pt)$);
   \coordinate (liminfizda) at ($(namespace.south west)-(\margenlateralizdo pt, \margeninf pt)$);
   \begin{scope}[on background layer]
     \node [background, fit= (liminfizda) (limsupdcha)] {};
   \end{scope}
\end{tikzpicture}
\caption{Nombre del objeto \textsf{TDoble}.}
\label{fig:nombre-objetos}
\end{figure}


\subsubsection{Tipo}
Cuando decimos ``tipo'', nos podemos referir a dos conceptos diferentes, aunque relacionados.
Por un lado, el tipo del sistema de objetos y, por otro, el tipo del lenguaje C. Por ejemplo, \textsf{GObject} es
un tipo del sistema de tipos. Pero, ``char'', o `double'', por otro lado son tipos del lenguaje C.
Cuando el significado de ``tipo'' quede claro por el contexto, diremos sencillamente ``tipo''; en caso contrario
diremos ``tipo de C'' o ``tipo del sistema''.

\subsubsection{Definición de \textsf{TDobleClass} y de \textsf{TDoble}}
  Nuestro objeto \textsf{TDoble} pertenecerá a la clase \textsf{TDobleClass}. La estructura en C de esta última es
  \begin{lstlisting}[language=C]
    typedef struct _TDobleClass TDobleClass;
    struct _TDobleClass {
      GObjectClass parent_class;
    };
  \end{lstlisting}

  \texttt{\_TDobleClass} es el nombre de una estructura en C y \texttt{TDobleClass} es \texttt{struct \_TDobleClass}.
  Así, \textsf{TDobleClass} es un tipo de C recién definido.
  En el código anterior, se usa \texttt{typedef} para definir un tipo de clase. El primer miembro de la estructura
  debe ser la estructura de la clase padre. \textsf{TDobleClass} no necesita más información. El tipo C de una
  instancia de \textsf{TDoble} es \texttt{TDoble}.
  \begin{lstlisting}[language=C]
    typedef struct _TDoble TDoble;
    struct _TDoble {
      GObject parent;
      double valor;
    };
  \end{lstlisting}
  
  Esto es similar a la estructura de la clase. Primero se usa \texttt{typedef} para definir el tipo en C de una
  instancia de la clase. El primer miembro de la estructura debe ser la estructura de la instancia padre.
  \textsf{TDoble} tiene su propio miembro ``\texttt{valor}'', que es el valor de las instancias de \textsf{TDoble}.
  La convención de código mostrada en los dos listados anteriores debe respetarse siempre.

  \subsection{Proceso de registro}
  \subsubsection{Procedimiento para crear un objeto derivado de \textsf{GObject}}
  Para crear un tipo del sistema, a partir de un tipo creado como una estructura en C,
  como \text{TDoble}, se llevan a cabo los siguientes pasos:
  \begin{enumerate}
    \tightlist
  \item Registro del tipo en C \texttt{TDoble} en el sistema de tipos.
  \item El sistema de tipos asigna memoria para \textsf{TDobleClass} y \textsf{TDoble}.
  \item Inicialización de \textsf{TDobleClass}.
  \item Inicialización de \textsf{TDoble}.
  \end{enumerate}

  \begin{figure}[ht]
  \centering
  \def\scl{1}
  \newcommand{\fondoTipoC}{green!20}
  \newcommand{\fondoTipoSistema}{green!25}
  \begin{tikzpicture}[%
    scale=\scl,
    every node/.style={font=\normalsize\sffamily},
    nubeSistemaTipos/.style={fill=yellow!75},
    nubeMemoria/.style={fill=black!2},
    tipoC/.style={fill=\fondoTipoC, font=\ttfamily, minimum size=8ex, inner sep=1em},
    tipoSistema/.style={fill=\fondoTipoSistema, minimum size=8ex, inner sep=1em},
    flecha/.style={line width=1.6pt, -Stealth[round]},  background/.style={
      line width=\bgborderwidth,
      draw=\bgbordercolor,
      fill=\bgcolor,
    },
   ]
   % COORDENADAS
   % - 
   % DIBUJO
   % Proceso de registro de una clase
   % Type System
   \node[nubeSistemaTipos, cloud, draw, aspect=2] (typesystem) {Sistema de tipos};
   % Memoria
   \node[nubeMemoria, cloud, draw, aspect=2, right=12em of typesystem] (memory)
   {\begin{tabular}{c} Memoria \\ (TDobleClass y TDoble) \end{tabular}};
   % TDoble (Tipo C)
   \node[tipoC, draw, above=8ex of typesystem] (tdobleCtype)
   {\begin{tabular}{c}TDoble\\\textcolor{black!70}{(Tipo C)}\end{tabular}};
   % Objeto TDoble
   \node[tipoSistema, draw, below=8ex of memory] (tdobleobject)
   {\begin{tabular}{c} Objeto TDoble \\ \textcolor{black!70}{(Tipo sistema)} \end{tabular}};
   % Clase TDobleClass
   \node[tipoSistema, draw, left=12em of tdobleobject] (tdobleclass)
   {\begin{tabular}{c} Clase TDobleClass \\ \textcolor{black!70}{(Tipo sistema)} \end{tabular}};
   % Flechas
   % TDoble (Tipo C) -> Sistema Tipos
   \draw[flecha] (tdobleCtype.south) --
   node[left] {\small $\mbfone$} node[right]  {\small Registro}
   (typesystem.north);
   % Sistema tipos -> memoria
   \draw[flecha] (typesystem.east) --
   node[below]{\small Asignación de memoria}
   node[above]{\small $\mbftwo$}
   (memory.west);
   % Memoria -> Clase TDobleClass (Tipo sistema)
   \draw[flecha] (memory.225) --
   node[above right, sloped]{\small $\mbfthree$}
   node[below right=0.2ex and -4ex, sloped]{\small Inicialización}
   (tdobleclass.north);
   % Memoria -> Objeto TDoble (Tipo sistema)
   \draw[flecha] (memory.south) --
   node[left] {\small $\mbffour$}
   node[right] {\small Inicialización}
   (tdobleobject.north);
   
% Fondo amarillo
   \def\margen{16}
   \coordinate (limizda) at ($(typesystem.west)-(\margen pt, 0pt)$);
   \coordinate(limdcha) at ($(memory.east)+(\margen pt, 0pt)$);
   \coordinate(liminf) at ($(tdobleobject.south)-(0pt, \margen pt)$);
   \coordinate(limsup) at ($(tdobleCtype.north)+(0pt, \margen pt)$);
   \begin{scope}[on background layer]
     \node [background, fit= (liminf) (limsup) (limizda) (limdcha)] {};
   \end{scope}
\end{tikzpicture}
\caption{Proceso de registro del objeto \textsf{TDoble}.}
\label{fig:proceso-registro}
\end{figure}

\subsubsection{Registro}
Generalmente, el proceso de registro se lleva a cabo mediante unas macros, como
\texttt{G\_DECLARE\_FINAL\_TYPE} y \texttt{G\_DEFINE\_FINAL\_TYPE}, de manera que no
necesitamos preocuparnos por los detalles. Pero aquí es importante entender el
sistema de tipos de \textsf{GObject}, por lo que empezaremos analizando el proceso
de registro sin macros.

Hay dos clases de tipos de \textsf{GObject}, estáticos y dinámicos. Los tipos estáticos
no destruyen su clase aunque se hubieran destruido todas sus instancias. Los dinámicos
destruyen su clase cuando se elimina su última instancia.

El tipo de \textsf{GObject}, y de todos los objetos que derivan de él, es estático.
La función que registra tipos estáticos es
\passthrough{\lstinline!g\_type\_register\_static!}.
El código que se muestra a continuación se encuentra en el fichero \textsf{gtype.h} de
\text{GLib}.

\begin{lstlisting}[language=C]
GType
g_type_register_static (GType           parent_type,
                        const gchar     *type_name,
                        const GTypeInfo *info,
                        GTypeFlags      flags);
\end{lstlisting}

Descripción de los parámetros implicados en el registro:
\begin{itemize}
  \tightlist
\item \texttt{parent\_type}: Es el nombre del tipo padre.
\item \texttt{*type\_name}: Es el nombre del tipo que se va a registrar,
  por ejemplo, "\textsf{TDoble}".
\item \texttt{*info}: Es una estructura \texttt{GTypeInfo} que contiene información acerca
  del tipo que se va a registrar. Esta estructura se explica cuando se termine esta
  descripción.
\item \texttt{flags}: Si el tipo que se registra es abstracto o es un valor de tipo
  abstracto\footnotemark{} hay que especificarlo aquí. En caso contrario su valor es cero.
  \footnotetext{No veo clara la diferencia entre un tipo abstracto y un valor de tipo
    abstracto. Aunque pienso que, por ahora, no necesito profundizar más.}
\end{itemize}
Después del registro, la función \passthrough{\lstinline!g\_type\_register\_static!} retorna
el tipo del nuevo objeto. La definición de la estructura \texttt{GTypeInfo} es
\begin{lstlisting}[language=C]
typedef struct _GTypeInfo  GTypeInfo;

struct _GTypeInfo
{
  /* interface types, classed types, instantiated types */
  guint16                class_size;

  GBaseInitFunc          base_init;
  GBaseFinalizeFunc      base_finalize;

  /* interface types, classed types, instantiated types */
  GClassInitFunc         class_init;
  GClassFinalizeFunc     class_finalize;
  gconstpointer          class_data;

  /* instantiated types */
  guint16                instance_size;
  guint16                n_preallocs;
  GInstanceInitFunc      instance_init;

  /* value handling */
  const GTypeValueTable  *value_table;
};
\end{lstlisting}

Esta estructura se debe crear antes del registro.

\begin{itemize}
  \tightlist
\item \texttt{class\_size}: Tamaño de la clase. Por ejemplo, el tamaño de la clase
  \textsf{TDoble} es "\texttt{sizeof (TDobleClass)}''.
\item \texttt{base\_init}, \text{base\_finalize}: Estas funciones inicializan/finalizan
  los miembros dinámicos de la clase. En la mayoría de los casos no son necesarias y
  su valor es \texttt{NULL}.
  Para más información ver:
  \href{https://docs.gtk.org/gobject/callback.BaseInitFunc.html}
  {\textit{GObject API Reference -- BaseInitFunc}} y
  \href{https://docs.gtk.org/gobject/callback.ClassInitFunc.html}
  {\textit{GObject API Reference -- ClassInitFunc}}.
\item \texttt{class\_init}: Esta función inicializa los miembros estáticos de la clase. Asigna tu función de
  inicialización de la clase a esta función.
  Por convenio, el nombre es \textsf{<espacio-de-nombres>\_<nombre>\_class\_init}.
\item \texttt{class\_finalize}: Esta función finaliza la clase. Pero, como el tipo de los objetos derivados de
  \textsf{GObject} es estático, no se les asigna ninguna función de finalización. Por tanto a \textsf{TDoble}
  se le asigna \texttt{NULL} aquí.
  Por convenio, el nombre es \textsf{<espacio-de-nombres>\_<nombre>\_class\_init}.
\item \texttt{class\_data}: Datos que el usuario le pasa a las funciones de los dos métodos anteriores
  de inicialización y finalización de la clase. Normalmente se asigna \texttt{NULL}.
\item \texttt{instance\_size}: El tamaño de cada objeto que se instancia. Por ejemplo, el de una instancia
  de \textsf{TDoble} es "\texttt{sizeof (TDoble)}".
\item \texttt{n\_preallocs}: Este campo se debe ignorar porque se usaba en la antigua versión de \textsf{GLib}.
\item \texttt{instance\_init}: Inicializa los miembros de la instancia. Asigna tu función de inicialización a este
  método. Por convenio, el nombre es \textsf{<espacio-de-nombres>\_<nombre>\_init}. En nuestro caso, con
  el objeto \textsf{GObject}, el nombre sería \textsf{TObject\_init}.
\item \texttt{*value\_table}:  Generalmente, este campo solo es útil para tipos fundamentales. Si el tipo deriva
  de \textsf{GObject}, se debe asignar \texttt{NULL}.
\end{itemize}
Esta información la almacena el sistema de tipos y se usa cuando se crea o destruye el objeto.
Los valores \texttt{class\_size} e \texttt{instance\_size} se usan para reservar memoria para la clase y la instancia,
respectivamente. Los métodos \texttt{class\_init} e \texttt{instance\_init} se ejecutan cuando se inicializan
la clase y la instancia, también respectivamente.

\subsubsection{Ejemplo 3}
El siguiente ejemplo muestra cómo utilizar la función \passthrough{\lstinline!g\_type\_register\_static!}.
En la práctica se utilizará una macro que realiza esta tarea automáticamente. Pero aquí se realiza sin
la macro con fines didácticos.

En el directorio 'prog' se encuentran los programas de ejemplo.
Para compilarlos todos basta con hacer
\begin{lstlisting}[language=bash]
  $ cd prog
  $ make
\end{lstlisting}
o bien, solo el tercer ejemplo:
\begin{lstlisting}[language=bash]
  $ cd prog
  $ make ejemplo03
\end{lstlisting}
Para borrar los ejecutables:
\begin{lstlisting}[language=bash]
  $ cd prog
  $ make clean
\end{lstlisting}


El listado es:

\begin{lstlisting}[language=C, numbers=left]
/*
 * ejemplo03.c
 * Prueba la función 'g_type_register_static'.
 */

#include <locale.h>
#include <glib-object.h>
 
 #define T_TYPE_DOBLE  (t_doble_get_type ())
 
 typedef struct _TDoble TDoble;
 struct _TDoble {
   GObject parent;
   double value;
 };
 
 typedef struct _TDobleClass TDobleClass;
 struct _TDobleClass {
   GObjectClass parent_class;
 };
 
 static void
 t_doble_class_init (TDobleClass *class) {
 }
 
 static void
 t_doble_init (TDoble *self) {
 }
 
 GType
 t_doble_get_type (void) {
   static GType type = 0;
   GTypeInfo info;
 
   if (type == 0) {
     info.class_size = sizeof (TDobleClass);
     info.base_init = NULL;
     info.base_finalize = NULL;
     info.class_init = (GClassInitFunc)  t_doble_class_init;
     info.class_finalize = NULL;
     info.class_data = NULL;
     info.instance_size = sizeof (TDoble);
     info.n_preallocs = 0;
     info.instance_init = (GInstanceInitFunc)  t_doble_init;
     info.value_table = NULL;
     type = g_type_register_static (G_TYPE_OBJECT, "TDoble", &info, 0);
   }
   return type;
 }
 
 int
 main (int argc, char **argv) {
   GType dtype;
   TDoble *d;

  // Para que g_print no transforme la codificación de caracteres
  // por su cuenta y no se vean los acentos.
  setlocale(LC_CTYPE, "");
   
  dtype = t_doble_get_type (); /* equivale a  'dtype = T_TYPE_DOBLE' */
  if (dtype)
    g_print ("Registro correcto. El tipo es %lx.\n", dtype);
  else
    g_print ("Registro incorrecto.\n");
 
  d = g_object_new (T_TYPE_DOBLE, NULL);
  if (d)
    g_print ("La instancia se ha creado correctamente. Su dirección ess %p.\n", d);
  else
  g_print ("Error en la creación de la instancia.\n");
  
  g_object_unref (d); /* Elimina el objeto 'd'. */
  
  return 0;
 }
 \end{lstlisting}

 \subsubsection{Salida del programa 'ejemplo03'}
\textsf{Registro correcto. El tipo es 0x563c801b24f0.}\par
\textsf{La instancia se ha creado correctamente Su dirección es 0x563c801b4000.}\par

\subsubsection{Comentarios}
\begin{itemize}
\item Línea 9:\par
  Se define la macro \texttt{T\_TYPE\_DOBLE}, que se sustituye por la función
  \passthrough{\lstinline!t\_doble\_get\_type!}, Esta función se definirá manualmente más adelante porque
  vamos a registrar la clase \textsf{T\_Doble\_Class} y  el objeto \textsf{T\_Doble} manualmente, con fines didácticos.
  Esta función, a su vez, ejecuta \passthrough{\lstinline!g\_type\_register\_static!}, que realiza
  el proceso de registro; todo esto se hará en las líneas 30--49.
  Ten en cuenta que normalmente, el sistema de tipos generará unas macros automáticamente que se encargarán
  de esta tarea, cuando las llamemos en el código.
\item Líneas 11--15:\par
  Se define el tipo C del objeto \textsf{TDoble} y la estructura que lo define \texttt{struct \_TDoble}.
\item Líneas 17--20:\par
  Se define el tipo C de la clase \textsf{TDobleClass} y la estructura que lo define \texttt{struct \_TDobleClass}.
\item Líneas 22--28:\par
  Se definen las funciones que inicializan la clase y la instancia. El argumento \texttt{class} es un puntero a la
  estructura de la clase y \texttt{self} apunta a la estructura de la instancia. Como se aprecia, no
  necesitan ningún código en este caso, pero son necesarias para el registro.
\item Líneas 30--49:\par
  Se define la función \passthrough{\lstinline!t\_doble\_get\_type!}, a la que se hacía referencia en la línea 9.
  Esta función sustituye a la macro \texttt{T\_TYPE\_DOBLE} y retorna el tipo del objeto \textsf{TDoble}.
  Por convenio, el nombre es \textsf{<espacio-de-nombres>\_<nombre>\_get\_type}. Esta función reemplaza
  a la macro \textsf{<ESPACIO-DE-NOMBRES>\_TYPE\_<NOMBRE>} (todos los caracteres en mayúsculas).
  En su código se define una variable estática, \texttt{type}, para mantener el tipo del objeto que se define.
  Al ejecutarse por primera vez la función, se asigna el valor cero a la variable (\texttt{type = 0}).
  Después, se llama a g\_type\_register\_static para registrar el objeto en el sistema de tipos. En las subsecuentes
  llamadas, la función lo único que se hace es retornar el tipo que se definió en la primera ejecución.\par
  Cuando se utilicen las macros \texttt{G\_DECLARE\_FINAL\_TYPE} y \texttt{G\_DEFINE\_FINAL\_TYPE}, no será
  necesario definir la función esta función \passthrough{\lstinline!t\_doble\_get\_type!}; de esto se encargarán las macros anteriores.
\item Líneas 36--46:\par
  Establece campos de la estructura \texttt{info} y llama a \passthrough{\lstinline!g\_type\_register\_static!}.
\item Líneas 51--75:\par
  La función principal. Asigna a la variable \texttt{dtype} el tipo de objeto \textsf{TDoble} y escribe el valor
  del tipo \text{TDoble}.
\item Líneas 53--54:\par
  Se define la variable \texttt{dtype}, que guardará el tipo del sistema de objeto \textsf{T\_DOBLE}, y de la
  variable \texttt{d}, que es un puntero a la instancia de \textsf{T\_DOBLE}, que se creará en la línea 66.
\item Línea 58:\par
  Se le asigna la cadena vacía a la variable de estado \texttt{LC\_CTYPE} para que la función
  \passthrough{\lstinline!g\_print!} no cambie el el sistema de caracteres del texto que imprimirá.
  Esto funcionará si la consola que se utiliza para ejecutar el programa utiliza el mismo sistema de caracteres
  que las cadenas (en este caso utilizamos UTF-8).
\item Líneas 60--64:\par
  Se guarda en la variable \texttt{dtype} el valor del tipo de objeto \textsf{T\_DOBLE} y se muestra en la consola.
  También se podría haber sustituido esta línea por la equivalente, utilizando la macro de la línea 9:
  "\texttt{dtype = T\_TYPE\_DOBLE}".
\item Líneas 66--70:\par
  Se crea una instancia \textsf{T\_DOBLE} y se almacena en el puntero \texttt{d}. Se muestra en la consola su
  dirección. En la referencia de la API de \textsf{GObject} se dice que la función
  \passthrough{\lstinline!g\_object\_new!} returna un puntero a \textsf{GObject}, pero en realidad retorna un
  \texttt{gpointer}, que es lo mismo que \texttt{void *}, que puede asignarse a cualquier puntero, sea cual sea
  su tipo; en este caso, \texttt{d} se declaró como un puntero a \texttt{TDoble}, por lo que la línea
  "\texttt{d = g\_object\_new (T\_TYPE\_DOBLE, NULL)}" es correcta. Nótese que si la función
  \passthrough{\lstinline!g\_object\_new!} retornara un puntero a \textsf{GObject}, sería necesario indicarlo:
  "\texttt{d = (gpointer) g\_object\_new (T\_TYPE\_DOBLE, NULL)}".
\item Línea 72:\par
  Se elimina la instancia llamando a la función \passthrough{\lstinline!g\_object\_unref!}.
\end{itemize}
 \par


  

%%% Local Variables:
%%% coding: utf-8
%%% mode: latex
%%% TeX-engine: luatex
%%% TeX-master: "../GObject_tutorial_es.tex"
%%% End:

% LaTeX-command: "lualatex --shell-escape"
