% registro.tex
%
% Copyright (C) 2024 José A. Navarro Ramón <janr.devel@gmail.com>
% 1) Código LuaLatex:
%    Licencia GPL-2.
% 2) Producto en pdf, postscript, etc.:
%    Licencia Creative Commons Recognition Share alike. (CC-BY-SA)

\section{Sistema de tipos y registro de clases}
\subsection{Sistema de tipos} \label{subsec:sistematipos}
\subsubsection{Introducción}
\textsf{GObject} es un objeto básico. Es muy simple y no se puede hacer mucho con él, excepto crear
clases derivadas e instanciar nuevos tipos de objetos.
En realidad esta es la característica más importante de \textsf{GObject}.
Aquí se describe como definir clases derivadas de \textsf{GObject}.

En esta sección se crearán objetos que representan números reales. Este ejemplo no será muy útil, porque
el lenguaje C ya tiene un tipo \emph{double} que representa números reales. Sin embargo, será útil para
conocer la técnica para definir clases y objetos derivados de \textsf{GObject}.

\subsubsection{Convenio de nombres}
Primero se debe conocer el convenio de nombres que se usará. El nombre de un objeto tiene dos partes:
\begin{enumerate}
  \tightlist
\item Un \href{https://es.wikipedia.org/wiki/Espacio_de_nombres}{espacio de nombres}
  (\href{https://en.wikipedia.org/wiki/Namespace}{\textit{namespace}}).
\item Un nombre propiamente dicho, que se considera incluido en el espacio de nombres.
\end{enumerate}

Por ejemplo, \textsf{GObject} consiste en un espacio de nombres ``\textsf{G}'' y un nombre ``\textsf{Object}''.
\textsf{GtkWidget} tiene un espacio de nombres ``\textsf{Gtk}'' y el nombre ``\textsf{Widget}''.
Para el objeto de números reales que pondremos como ejemplo, se decide poner ``\textsf{T}'' como espacio
de nombres y ``\textsf{Doble}'' como nombre. Así, estos objetos se identificarán como \textsf{TDoble}.
Además serán objetos que derivan de \textsf{GObject}, representan números reales y el tipo del número
será \textit{double}.

\begin{figure}[ht]
  \centering
  \def\scl{1}
  \begin{tikzpicture}[%
    scale=\scl,
    every node/.style={font=\LARGE\sffamily, minimum size= 8ex},
     background/.style={
      line width=\bgborderwidth,
      draw=\bgbordercolor,
      fill=\bgcolor,
    },
   ]
   % COORDENADAS
   % - 
   % DIBUJO
   % Convenio de nombres de objetos
   \node[draw] (namespace)
   {\begin{tabular}{c} \textcolor{gray}{Espacio de nombres} \\ T \end{tabular}};
   \node [draw, right=1em of namespace] (name)
   {\begin{tabular}{c} \textcolor{gray}{Nombre} \\ Doble \end{tabular}};
   \node [right=1em of name] (tdoble) {$\equiv$ TDoble}; 
   % Fondo amarillo
   \def\margensup{18}
   \def\margeninf{12}
   \def\margenlateralizdo{18}
   \def\margenlateraldcho{12}
   \coordinate (limsupdcha) at ($(tdoble.north east)+(\margenlateraldcho pt, \margensup pt)$);
   \coordinate (liminfizda) at ($(namespace.south west)-(\margenlateralizdo pt, \margeninf pt)$);
   \begin{scope}[on background layer]
     \node [background, fit= (liminfizda) (limsupdcha)] {};
   \end{scope}
\end{tikzpicture}
\caption{Nombre del objeto \textsf{TDoble}.}
\label{fig:nombre-objetos}
\end{figure}


\subsubsection{Tipo}
Cuando decimos ``tipo'', nos podemos referir a dos conceptos diferentes, aunque relacionados.
Por un lado, el tipo del sistema de objetos y, por otro, el tipo del lenguaje C. Por ejemplo, \textsf{GObject} es
un tipo del sistema de tipos. Pero, ``char'', o `double'', por otro lado son tipos del lenguaje C.
Cuando el significado de ``tipo'' quede claro por el contexto, diremos sencillamente ``tipo''; en caso contrario
diremos ``tipo de C'' o ``tipo del sistema''.

\subsubsection{Definición de \textsf{TDobleClass} y de \textsf{TDoble}}
  Nuestro objeto \textsf{TDoble} pertenecerá a la clase \textsf{TDobleClass}. La estructura en C de esta última es
  \begin{lstlisting}[language=C]
    typedef struct _TDobleClass TDobleClass;
    struct _TDobleClass {
      GObjectClass parent_class;
    };
  \end{lstlisting}

  \texttt{\_TDobleClass} es el nombre de una estructura en C y \texttt{TDobleClass} es \texttt{struct \_TDobleClass}.
  Así, \textsf{TDobleClass} es un tipo de C recién definido.
  En el código anterior, se usa \texttt{typedef} para definir un tipo de clase. El primer miembro de la estructura
  debe ser la estructura de la clase padre. \textsf{TDobleClass} no necesita más información. El tipo C de una
  instancia de \textsf{TDoble} es \texttt{TDoble}.
  \begin{lstlisting}[language=C]
    typedef struct _TDoble TDoble;
    struct _TDoble {
      GObject parent;
      double valor;
    };
  \end{lstlisting}
  
  Esto es similar a la estructura de la clase. Primero se usa \texttt{typedef} para definir el tipo en C de una
  instancia de la clase. El primer miembro de la estructura debe ser la estructura de la instancia padre.
  \textsf{TDoble} tiene su propio miembro ``\texttt{valor}'', que es el valor de las instancias de \textsf{TDoble}.
  La convención de código mostrada en los dos listados anteriores debe respetarse siempre.

  \subsection{Proceso de registro}
  \subsubsection{Procedimiento para crear un objeto derivado de \textsf{GObject}}
  Para crear un tipo del sistema, a partir de un tipo creado como una estructura en C,
  como \text{TDoble}, se llevan a cabo los siguientes pasos:
  \begin{enumerate}
    \tightlist
  \item Registro del tipo en C \texttt{TDoble} en el sistema de tipos.
  \item El sistema de tipos asigna memoria para \textsf{TDobleClass} y \textsf{TDoble}.
  \item Inicialización de \textsf{TDobleClass}.
  \item Inicialización de \textsf{TDoble}.
  \end{enumerate}

  \begin{figure}[ht]
  \centering
  \def\scl{1}
  \newcommand{\fondoTipoC}{green!20}
  \newcommand{\fondoTipoSistema}{green!25}
  \begin{tikzpicture}[%
    scale=\scl,
    every node/.style={font=\normalsize\sffamily},
    nubeSistemaTipos/.style={fill=yellow!75},
    nubeMemoria/.style={fill=black!2},
    tipoC/.style={fill=\fondoTipoC, font=\ttfamily, minimum size=8ex, inner sep=1em},
    tipoSistema/.style={fill=\fondoTipoSistema, minimum size=8ex, inner sep=1em},
    flecha/.style={line width=1.6pt, -Stealth[round]},  background/.style={
      line width=\bgborderwidth,
      draw=\bgbordercolor,
      fill=\bgcolor,
    },
   ]
   % COORDENADAS
   % - 
   % DIBUJO
   % Proceso de registro de una clase
   % Type System
   \node[nubeSistemaTipos, cloud, draw, aspect=2] (typesystem) {Sistema de tipos};
   % Memoria
   \node[nubeMemoria, cloud, draw, aspect=2, right=12em of typesystem] (memory)
   {\begin{tabular}{c} Memoria \\ (TDobleClass y TDoble) \end{tabular}};
   % TDoble (Tipo C)
   \node[tipoC, draw, above=8ex of typesystem] (tdobleCtype)
   {\begin{tabular}{c}TDoble\\\textcolor{black!70}{(Tipo C)}\end{tabular}};
   % Objeto TDoble
   \node[tipoSistema, draw, below=8ex of memory] (tdobleobject)
   {\begin{tabular}{c} Objeto TDoble \\ \textcolor{black!70}{(Tipo sistema)} \end{tabular}};
   % Clase TDobleClass
   \node[tipoSistema, draw, left=12em of tdobleobject] (tdobleclass)
   {\begin{tabular}{c} Clase TDobleClass \\ \textcolor{black!70}{(Tipo sistema)} \end{tabular}};
   % Flechas
   % TDoble (Tipo C) -> Sistema Tipos
   \draw[flecha] (tdobleCtype.south) --
   node[left] {\small $\mbfone$} node[right]  {\small Registro}
   (typesystem.north);
   % Sistema tipos -> memoria
   \draw[flecha] (typesystem.east) --
   node[below]{\small Asignación de memoria}
   node[above]{\small $\mbftwo$}
   (memory.west);
   % Memoria -> Clase TDobleClass (Tipo sistema)
   \draw[flecha] (memory.225) --
   node[above right, sloped]{\small $\mbfthree$}
   node[below right=0.2ex and -4ex, sloped]{\small Inicialización}
   (tdobleclass.north);
   % Memoria -> Objeto TDoble (Tipo sistema)
   \draw[flecha] (memory.south) --
   node[left] {\small $\mbffour$}
   node[right] {\small Inicialización}
   (tdobleobject.north);
   
% Fondo amarillo
   \def\margen{16}
   \coordinate (limizda) at ($(typesystem.west)-(\margen pt, 0pt)$);
   \coordinate(limdcha) at ($(memory.east)+(\margen pt, 0pt)$);
   \coordinate(liminf) at ($(tdobleobject.south)-(0pt, \margen pt)$);
   \coordinate(limsup) at ($(tdobleCtype.north)+(0pt, \margen pt)$);
   \begin{scope}[on background layer]
     \node [background, fit= (liminf) (limsup) (limizda) (limdcha)] {};
   \end{scope}
\end{tikzpicture}
\caption{Proceso de registro del objeto \textsf{TDoble}.}
\label{fig:proceso-registro}
\end{figure}

\subsubsection{Registro}
Generalmente, el proceso de registro se lleva a cabo mediante unas macros, como
\texttt{G\_DECLARE\_FINAL\_TYPE} y \texttt{G\_DEFINE\_FINAL\_TYPE}, de manera que no
necesitamos preocuparnos por los detalles. Pero aquí es importante entender el
sistema de tipos de \textsf{GObject}, por lo que empezaremos analizando el proceso
de registro sin macros.

Hay dos clases de tipos de \textsf{GObject}, estáticos y dinámicos. Los tipos estáticos
no destruyen su clase aunque se hubieran destruido todas sus instancias. Los dinámicos
destruyen su clase cuando se elimina su última instancia.

El tipo de \textsf{GObject}, y de todos los objetos que derivan de él, es estático.
La función que registra tipos estáticos es
\passthrough{\lstinline!g\_type\_register\_static!}.
El código que se muestra a continuación se encuentra en el fichero \textsf{gtype.h} de
\text{GLib}.

\begin{lstlisting}[language=C]
GType
g_type_register_static (GType           parent_type,
                        const gchar     *type_name,
                        const GTypeInfo *info,
                        GTypeFlags      flags);
\end{lstlisting}

Descripción de los parámetros implicados en el registro:
\begin{itemize}
  \tightlist
\item \texttt{parent\_type}: Es el nombre del tipo padre.
\item \texttt{*type\_name}: Es el nombre del tipo que se va a registrar,
  por ejemplo, "\textsf{TDoble}".
\item \texttt{*info}: Es una estructura \texttt{GTypeInfo} que contiene información acerca
  del tipo que se va a registrar. Esta estructura se explica cuando se termine esta
  descripción.
\item \texttt{flags}: Si el tipo que se registra es abstracto o es un valor de tipo
  abstracto\footnotemark{} hay que especificarlo aquí. En caso contrario su valor es cero.
  \footnotetext{No veo clara la diferencia entre un tipo abstracto y un valor de tipo
    abstracto. Aunque pienso que, por ahora, no necesito profundizar más.}
\end{itemize}
Después del registro, la función \passthrough{\lstinline!g\_type\_register\_static!} retorna
el tipo del nuevo objeto. La definición de la estructura \texttt{GTypeInfo} es
\begin{lstlisting}[language=C]
typedef struct _GTypeInfo  GTypeInfo;

struct _GTypeInfo
{
  /* interface types, classed types, instantiated types */
  guint16                class_size;

  GBaseInitFunc          base_init;
  GBaseFinalizeFunc      base_finalize;

  /* interface types, classed types, instantiated types */
  GClassInitFunc         class_init;
  GClassFinalizeFunc     class_finalize;
  gconstpointer          class_data;

  /* instantiated types */
  guint16                instance_size;
  guint16                n_preallocs;
  GInstanceInitFunc      instance_init;

  /* value handling */
  const GTypeValueTable  *value_table;
};
\end{lstlisting}

Esta estructura se debe crear antes del registro.

\begin{itemize}
  \tightlist
\item \texttt{class\_size}: Tamaño de la clase. Por ejemplo, el tamaño de la clase
  \textsf{TDoble} es "\texttt{sizeof (TDobleClass)}''.
\item \texttt{base\_init}, \text{base\_finalize}: Estas funciones inicializan/finalizan
  los miembros dinámicos de la clase. En la mayoría de los casos no son necesarias y
  su valor es \texttt{NULL}.
  Para más información ver:
  \href{https://docs.gtk.org/gobject/callback.BaseInitFunc.html}
  {\textit{GObject API Reference -- BaseInitFunc}} y
  \href{https://docs.gtk.org/gobject/callback.ClassInitFunc.html}
  {\textit{GObject API Reference -- ClassInitFunc}}.
\item \texttt{class\_init}: Esta función inicializa los miembros estáticos de la clase. Asigna tu función de
  inicialización de la clase a esta función.
  Por convenio, el nombre es \textsf{<espacio-de-nombres>\_<nombre>\_class\_init}.
\item \texttt{class\_finalize}: Esta función finaliza la clase. Pero, como el tipo de los objetos derivados de
  \textsf{GObject} es estático, no se les asigna ninguna función de finalización. Por tanto a \textsf{TDoble}
  se le asigna \texttt{NULL} aquí.
  Por convenio, el nombre es \textsf{<espacio-de-nombres>\_<nombre>\_class\_init}.
\item \texttt{class\_data}: Datos que el usuario le pasa a las funciones de los dos métodos anteriores
  de inicialización y finalización de la clase. Normalmente se asigna \texttt{NULL}.
\item \texttt{instance\_size}: El tamaño de cada objeto que se instancia. Por ejemplo, el de una instancia
  de \textsf{TDoble} es "\texttt{sizeof (TDoble)}".
\item \texttt{n\_preallocs}:
\item \texttt{instance\_init}:
\item \texttt{*value\_table}:
\end{itemize}

%n_preallocs: This is ignored. it has been used by the old version of Glib.
%instance_init: Initializes instance members. Assign your instance initialization function to instance_init member. By convention, the name is <name space>_<name>_init, for example, t_double_init.
%value_table: This is usually only useful for fundamental types. If the type is descendant of GObject, assign NULL.
%These information is kept by the type system and used when the object is created or destroyed. Class_size and instance_size are used to allocate memory for the class and instance. Class_init and instance_init functions are called when class or instance is initialized.

%%% Local Variables:
%%% coding: utf-8
%%% mode: latex
%%% TeX-engine: luatex
%%% TeX-master: "../GObject_tutorial_es.tex"
%%% End:

% LaTeX-command: "lualatex --shell-escape"
