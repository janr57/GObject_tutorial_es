x% registro.tex
%
% Copyright (C) 2024 José A. Navarro Ramón <janr.devel@gmail.com>
% 1) Código LuaLatex:
%    Licencia GPL-2.
% 2) Producto en pdf, postscript, etc.:
%    Licencia Creative Commons Recognition Share alike. (CC-BY-SA)

\section{Sistema de tipos}
%\subsection{Sistema de tipos} \label{subsec:sistematipos}
\subsection{Introducción}
\textsf{GObject} es un objeto básico. Es muy simple y no se puede hacer mucho con él, excepto crear
clases derivadas e instanciar nuevos tipos de objetos.
En realidad esta es la característica más importante de \textsf{GObject}.
Aquí se describe como definir clases derivadas de \textsf{GObject}.

En esta sección se crearán objetos que representan números reales. Este ejemplo no será muy útil, porque
el lenguaje C ya tiene un tipo \emph{double} que representa números reales. Sin embargo, será útil para
conocer la técnica para definir clases y objetos derivados de \textsf{GObject}.

\subsection{Convenio de nombres}
Primero se debe conocer el convenio de nombres que se usará. El nombre de un objeto tiene dos partes:
\begin{enumerate}
  \tightlist
\item Un \href{https://es.wikipedia.org/wiki/Espacio_de_nombres}{espacio de nombres}
  (\href{https://en.wikipedia.org/wiki/Namespace}{\textit{namespace}}).
\item Un nombre propiamente dicho, que se considera incluido en el espacio de nombres.
\end{enumerate}

Por ejemplo, \textsf{GObject} consiste en un espacio de nombres ``\textsf{G}'' y un nombre ``\textsf{Object}''.
\textsf{GtkWidget} tiene un espacio de nombres ``\textsf{Gtk}'' y el nombre ``\textsf{Widget}''.
Para el objeto de números reales que pondremos como ejemplo, se decide poner ``\textsf{T}'' como espacio
de nombres y ``\textsf{Doble}'' como nombre. Así, estos objetos se identificarán como \textsf{TDoble}.
Además serán objetos que derivan de \textsf{GObject}, representan números reales y el tipo del número
será \textit{double}.

\begin{figure}[ht]
  \centering
  \def\scl{1}
  \begin{tikzpicture}[%
    scale=\scl,
    every node/.style={font=\LARGE\sffamily, minimum size= 8ex},
     background/.style={
      line width=\bgborderwidth,
      draw=\bgbordercolor,
      fill=\bgcolor,
    },
   ]
   % COORDENADAS
   % - 
   % DIBUJO
   % Convenio de nombres de objetos
   \node[draw] (namespace)
   {\begin{tabular}{c} \textcolor{gray}{Espacio de nombres} \\ T \end{tabular}};
   \node [draw, right=1em of namespace] (name)
   {\begin{tabular}{c} \textcolor{gray}{Nombre} \\ Doble \end{tabular}};
   \node [right=1em of name] (tdoble) {$\equiv$ TDoble}; 
   % Fondo amarillo
   \def\margensup{18}
   \def\margeninf{12}
   \def\margenlateralizdo{18}
   \def\margenlateraldcho{12}
   \coordinate (limsupdcha) at ($(tdoble.north east)+(\margenlateraldcho pt, \margensup pt)$);
   \coordinate (liminfizda) at ($(namespace.south west)-(\margenlateralizdo pt, \margeninf pt)$);
   \begin{scope}[on background layer]
     \node [background, fit= (liminfizda) (limsupdcha)] {};
   \end{scope}
\end{tikzpicture}
\caption{Nombre del objeto \textsf{TDoble}.}
\label{fig:nombre-objetos}
\end{figure}

\subsection{Tipo}
Cuando decimos ``tipo'', nos podemos referir a dos conceptos diferentes, aunque relacionados.
Por un lado, el tipo del sistema de objetos y, por otro, el tipo del lenguaje C. Por ejemplo, \textsf{GObject} es
un tipo del sistema de tipos. Pero, ``char'', o `double'', por otro lado son tipos del lenguaje C.
Cuando el significado de ``tipo'' quede claro por el contexto, diremos sencillamente ``tipo''; en caso contrario
diremos ``tipo de C'' o ``tipo del sistema''.

\subsubsection{Definición de \textsf{TDobleClass} y de \textsf{TDoble}}
  Nuestro objeto \textsf{TDoble} pertenecerá a la clase \textsf{TDobleClass}. La estructura en C de esta última es
  \begin{lstlisting}[language=C]
    typedef struct _TDobleClass TDobleClass;
    struct _TDobleClass {
      GObjectClass parent_class;
    };
  \end{lstlisting}

  \texttt{\_TDobleClass} es el nombre de una estructura en C y \texttt{TDobleClass} es \texttt{struct \_TDobleClass}.
  Así, \textsf{TDobleClass} es un tipo de C recién definido.
  En el código anterior, se usa \texttt{typedef} para definir un tipo de clase. El primer miembro de la estructura
  debe ser la estructura de la clase padre. \textsf{TDobleClass} no necesita más información. El tipo C de una
  instancia de \textsf{TDoble} es \texttt{TDoble}.
  \begin{lstlisting}[language=C]
    typedef struct _TDoble TDoble;
    struct _TDoble {
      GObject parent;
      double valor;
    };
  \end{lstlisting}
  
  Esto es similar a la estructura de la clase. Primero se usa \texttt{typedef} para definir el tipo en C de una
  instancia de la clase. El primer miembro de la estructura debe ser la estructura de la instancia padre.
  \textsf{TDoble} tiene su propio miembro ``\texttt{valor}'', que es el valor de las instancias de \textsf{TDoble}.
  La convención de código mostrada en los dos listados anteriores debe respetarse siempre.

  \section{Proceso de registro}
  \subsection{Procedimiento para crear un objeto derivado de \textsf{GObject}}
  Para crear un tipo del sistema, a partir de un tipo creado como una estructura en C,
  como \text{TDoble}, se llevan a cabo los siguientes pasos:
  \begin{enumerate}
    \tightlist
  \item Registro del tipo en C \texttt{TDoble} en el sistema de tipos.
  \item El sistema de tipos asigna memoria para \textsf{TDobleClass} y \textsf{TDoble}.
  \item Inicialización de \textsf{TDobleClass}.
  \item Inicialización de \textsf{TDoble}.
  \end{enumerate}

  \begin{figure}[ht]
  \centering
  \def\scl{1}
  \newcommand{\fondoTipoC}{green!20}
  \newcommand{\fondoTipoSistema}{green!25}
  \begin{tikzpicture}[%
    scale=\scl,
    every node/.style={font=\normalsize\sffamily},
    nubeSistemaTipos/.style={fill=yellow!75},
    nubeMemoria/.style={fill=black!2},
    tipoC/.style={fill=\fondoTipoC, font=\ttfamily, minimum size=8ex, inner sep=1em},
    tipoSistema/.style={fill=\fondoTipoSistema, minimum size=8ex, inner sep=1em},
    flecha/.style={line width=1.6pt, -Stealth[round]},  background/.style={
      line width=\bgborderwidth,
      draw=\bgbordercolor,
      fill=\bgcolor,
    },
   ]
   % COORDENADAS
   % - 
   % DIBUJO
   % Proceso de registro de una clase
   % Type System
   \node[nubeSistemaTipos, cloud, draw, aspect=2] (typesystem) {Sistema de tipos};
   % Memoria
   \node[nubeMemoria, cloud, draw, aspect=2, right=12em of typesystem] (memory)
   {\begin{tabular}{c} Memoria \\ (TDobleClass y TDoble) \end{tabular}};
   % TDoble (Tipo C)
   \node[tipoC, draw, above=8ex of typesystem] (tdobleCtype)
   {\begin{tabular}{c}TDoble\\\textcolor{black!70}{(Tipo C)}\end{tabular}};
   % Objeto TDoble
   \node[tipoSistema, draw, below=8ex of memory] (tdobleobject)
   {\begin{tabular}{c} Objeto TDoble \\ \textcolor{black!70}{(Tipo sistema)} \end{tabular}};
   % Clase TDobleClass
   \node[tipoSistema, draw, left=12em of tdobleobject] (tdobleclass)
   {\begin{tabular}{c} Clase TDobleClass \\ \textcolor{black!70}{(Tipo sistema)} \end{tabular}};
   % Flechas
   % TDoble (Tipo C) -> Sistema Tipos
   \draw[flecha] (tdobleCtype.south) --
   node[left] {\small $\mbfone$} node[right]  {\small Registro}
   (typesystem.north);
   % Sistema tipos -> memoria
   \draw[flecha] (typesystem.east) --
   node[below]{\small Asignación de memoria}
   node[above]{\small $\mbftwo$}
   (memory.west);
   % Memoria -> Clase TDobleClass (Tipo sistema)
   \draw[flecha] (memory.225) --
   node[above right, sloped]{\small $\mbfthree$}
   node[below right=0.2ex and -4ex, sloped]{\small Inicialización}
   (tdobleclass.north);
   % Memoria -> Objeto TDoble (Tipo sistema)
   \draw[flecha] (memory.south) --
   node[left] {\small $\mbffour$}
   node[right] {\small Inicialización}
   (tdobleobject.north);
   
% Fondo amarillo
   \def\margen{16}
   \coordinate (limizda) at ($(typesystem.west)-(\margen pt, 0pt)$);
   \coordinate(limdcha) at ($(memory.east)+(\margen pt, 0pt)$);
   \coordinate(liminf) at ($(tdobleobject.south)-(0pt, \margen pt)$);
   \coordinate(limsup) at ($(tdobleCtype.north)+(0pt, \margen pt)$);
   \begin{scope}[on background layer]
     \node [background, fit= (liminf) (limsup) (limizda) (limdcha)] {};
   \end{scope}
\end{tikzpicture}
\caption{Proceso de registro del objeto \textsf{TDoble}.}
\label{fig:proceso-registro}
\end{figure}

\subsection{Registro realizado sin macros}
Generalmente, el proceso de registro se lleva a cabo mediante unas macros, como
\texttt{G\_DECLARE\_FINAL\_TYPE} y \texttt{G\_DEFINE\_FINAL\_TYPE}, de manera que no
necesitamos preocuparnos por los detalles. Pero aquí es importante entender el
sistema de tipos de \textsf{GObject}, por lo que empezaremos analizando el proceso
de registro sin macros.

Hay dos clases de tipos de \textsf{GObject}, estáticos y dinámicos. Los tipos estáticos
no destruyen su clase aunque se hubieran destruido todas sus instancias. Los dinámicos
destruyen su clase cuando se elimina su última instancia.

El tipo de \textsf{GObject}, y de todos los objetos que derivan de él, es estático.
La función que registra tipos estáticos es
\passthrough{\lstinline!g\_type\_register\_static!}.
El código que se muestra a continuación se encuentra en el fichero \textsf{gtype.h} de
\text{GLib}.

\begin{lstlisting}[language=C]
GType
g_type_register_static (GType           parent_type,
                        const gchar     *type_name,
                        const GTypeInfo *info,
                        GTypeFlags      flags);
\end{lstlisting}

Descripción de los parámetros implicados en el registro:
\begin{itemize}
  \tightlist
\item \texttt{parent\_type}: Es el nombre del tipo padre.
\item \texttt{*type\_name}: Es el nombre del tipo que se va a registrar,
  por ejemplo, "\textsf{TDoble}".
\item \texttt{*info}: Es una estructura \texttt{GTypeInfo} que contiene información acerca
  del tipo que se va a registrar. Esta estructura se explica cuando se termine esta
  descripción.
\item \texttt{flags}: Si el tipo que se registra es abstracto o es un valor de tipo
  abstracto\footnotemark{} hay que especificarlo aquí. En caso contrario su valor es cero.
  \footnotetext{No veo clara la diferencia entre un tipo abstracto y un valor de tipo
    abstracto. Aunque pienso que, por ahora, no necesito profundizar más.}
\end{itemize}
Después del registro, la función \passthrough{\lstinline!g\_type\_register\_static!} retorna
el tipo del nuevo objeto. La definición de la estructura \texttt{GTypeInfo} es
\begin{lstlisting}[language=C]
typedef struct _GTypeInfo  GTypeInfo;

struct _GTypeInfo
{
  /* interface types, classed types, instantiated types */
  guint16                class_size;

  GBaseInitFunc          base_init;
  GBaseFinalizeFunc      base_finalize;

  /* interface types, classed types, instantiated types */
  GClassInitFunc         class_init;
  GClassFinalizeFunc     class_finalize;
  gconstpointer          class_data;

  /* instantiated types */
  guint16                instance_size;
  guint16                n_preallocs;
  GInstanceInitFunc      instance_init;

  /* value handling */
  const GTypeValueTable  *value_table;
};
\end{lstlisting}

Esta estructura se debe crear antes del registro.

\begin{itemize}
  \tightlist
\item \texttt{class\_size}: Tamaño de la clase. Por ejemplo, el tamaño de la clase
  \textsf{TDoble} es "\texttt{sizeof (TDobleClass)}''.
\item \texttt{base\_init}, \text{base\_finalize}: Estas funciones inicializan/finalizan
  los miembros dinámicos de la clase. En la mayoría de los casos no son necesarias y
  su valor es \texttt{NULL}.
  Para más información ver:
  \href{https://docs.gtk.org/gobject/callback.BaseInitFunc.html}
  {\textit{GObject API Reference -- BaseInitFunc}} y
  \href{https://docs.gtk.org/gobject/callback.ClassInitFunc.html}
  {\textit{GObject API Reference -- ClassInitFunc}}.
\item \texttt{class\_init}: Esta función inicializa los miembros estáticos de la clase. Asigna tu función de
  inicialización de la clase a esta función.
  Por convenio, el nombre es \textsf{<espacio-de-nombres>\_<nombre>\_class\_init}.
\item \texttt{class\_finalize}: Esta función finaliza la clase. Pero, como el tipo de los objetos derivados de
  \textsf{GObject} es estático, no se les asigna ninguna función de finalización. Por tanto a \textsf{TDoble}
  se le asigna \texttt{NULL} aquí.
  Por convenio, el nombre es \textsf{<espacio-de-nombres>\_<nombre>\_class\_init}.
\item \texttt{class\_data}: Datos que el usuario le pasa a las funciones de los dos métodos anteriores
  de inicialización y finalización de la clase. Normalmente se asigna \texttt{NULL}.
\item \texttt{instance\_size}: El tamaño de cada objeto que se instancia. Por ejemplo, el de una instancia
  de \textsf{TDoble} es "\texttt{sizeof (TDoble)}".
\item \texttt{n\_preallocs}: Este campo se debe ignorar porque se usaba en la antigua versión de \textsf{GLib}.
\item \texttt{instance\_init}: Inicializa los miembros de la instancia. Asigna tu función de inicialización a este
  método. Por convenio, el nombre es \textsf{<espacio-de-nombres>\_<nombre>\_init}. En nuestro caso, con
  el objeto \textsf{GObject}, el nombre sería \textsf{TObject\_init}.
\item \texttt{*value\_table}:  Generalmente, este campo solo es útil para tipos fundamentales. Si el tipo deriva
  de \textsf{GObject}, se debe asignar \texttt{NULL}.
\end{itemize}
Esta información la almacena el sistema de tipos y se usa cuando se crea o destruye el objeto.
Los valores \texttt{class\_size} e \texttt{instance\_size} se usan para reservar memoria para la clase y la instancia,
respectivamente. Los métodos \texttt{class\_init} e \texttt{instance\_init} se ejecutan cuando se inicializan
la clase y la instancia, también respectivamente.

\subsubsection{Ejemplo 3}
El siguiente ejemplo muestra cómo utilizar la función \passthrough{\lstinline!g\_type\_register\_static!}.
En la práctica se utilizará una macro que realiza esta tarea automáticamente. Pero aquí se realiza sin
la macro con fines didácticos.

En el directorio 'prog' se encuentran los programas de ejemplo.
Para compilarlos todos basta con hacer
\begin{lstlisting}[language=bash]
  $ cd prog
  $ make
\end{lstlisting}
o bien, solo el tercer ejemplo:
\begin{lstlisting}[language=bash]
  $ cd prog
  $ make ejemplo03
\end{lstlisting}
Para borrar los ejecutables:
\begin{lstlisting}[language=bash]
  $ cd prog
  $ make clean
\end{lstlisting}


El listado es:

\begin{lstlisting}[language=C, numbers=left]
/*
 * ejemplo03.c
 * Prueba la función 'g_type_register_static'.
 */

#include <locale.h>
#include <glib-object.h>
 
 #define T_TYPE_DOBLE  (t_doble_get_type ())
 
 typedef struct _TDoble TDoble;
 struct _TDoble {
   GObject parent;
   double value;
 };
 
 typedef struct _TDobleClass TDobleClass;
 struct _TDobleClass {
   GObjectClass parent_class;
 };
 
 static void
 t_doble_class_init (TDobleClass *class) {
 }
 
 static void
 t_doble_init (TDoble *self) {
 }
 
 GType
 t_doble_get_type (void) {
   static GType type = 0;
   GTypeInfo info;
 
   if (type == 0) {
     info.class_size = sizeof (TDobleClass);
     info.base_init = NULL;
     info.base_finalize = NULL;
     info.class_init = (GClassInitFunc)  t_doble_class_init;
     info.class_finalize = NULL;
     info.class_data = NULL;
     info.instance_size = sizeof (TDoble);
     info.n_preallocs = 0;
     info.instance_init = (GInstanceInitFunc)  t_doble_init;
     info.value_table = NULL;
     type = g_type_register_static (G_TYPE_OBJECT, "TDoble", &info, 0);
   }
   return type;
 }
 
 int
 main (int argc, char **argv) {
   GType dtype;
   TDoble *d;

  // Para que g_print no transforme la codificación de caracteres
  // por su cuenta y no se vean los acentos.
  setlocale(LC_CTYPE, "");
   
  dtype = t_doble_get_type (); /* equivale a  'dtype = T_TYPE_DOBLE' */
  if (dtype) {
    g_print ("Registro correcto. El tipo es %lx.\n", dtype);
    } else {
      g_print ("Registro incorrecto.\n");
    }
 
  d = g_object_new (T_TYPE_DOBLE, NULL);
  if (d) {
    g_print ("La instancia se ha creado correctamente. Su dirección es %p.\n", d);
  } else {
    g_print ("Error en la creación de la instancia.\n");
  }
  
  g_object_unref (d); /* Elimina el objeto 'd'. */
  
  return 0;
 }
 \end{lstlisting}

 \subsubsection{Salida del programa 'ejemplo03'}
\textsf{Registro correcto. El tipo es 0x563c801b24f0.}\par
\textsf{La instancia se ha creado correctamente Su dirección es 0x563c801b4000.}\par

\subsubsection{Comentarios}
\begin{itemize}
\item Línea 9:\par
  Se define la macro \texttt{T\_TYPE\_DOBLE}, que se sustituye por la función
  \passthrough{\lstinline!t\_doble\_get\_type!}, Esta función se definirá manualmente más adelante porque
  vamos a registrar la clase \textsf{T\_Doble\_Class} y  el objeto \textsf{T\_Doble} manualmente, con fines didácticos.
  Esta función, a su vez, ejecuta \passthrough{\lstinline!g\_type\_register\_static!}, que realiza
  el proceso de registro; todo esto se hará en las líneas 30--49.
  Ten en cuenta que normalmente, el sistema de tipos generará unas macros automáticamente que se encargarán
  de esta tarea, cuando las llamemos en el código.
\item Líneas 11--15:\par
  Se define el tipo C del objeto \textsf{TDoble} y la estructura que lo define \texttt{struct \_TDoble}.
\item Líneas 17--20:\par
  Se define el tipo C de la clase \textsf{TDobleClass} y la estructura que lo define \texttt{struct \_TDobleClass}.
\item Líneas 22--28:\par
  Se definen las funciones que inicializan la clase y la instancia. El argumento \texttt{class} es un puntero a la
  estructura de la clase y \texttt{self} apunta a la estructura de la instancia. Como se aprecia, no
  necesitan ningún código en este caso, pero son necesarias para el registro.
\item Líneas 30--49:\par
  Se define la función \passthrough{\lstinline!t\_doble\_get\_type!}, a la que se hacía referencia en la línea 9.
  Esta función sustituye a la macro \texttt{T\_TYPE\_DOBLE} y retorna el tipo del objeto \textsf{TDoble}.
  Por convenio, el nombre es \textsf{<espacio-de-nombres>\_<nombre>\_get\_type}. Esta función reemplaza
  a la macro \textsf{<ESPACIO-DE-NOMBRES>\_TYPE\_<NOMBRE>} (todos los caracteres en mayúsculas).
  En su código se define una variable estática, \texttt{type}, para mantener el tipo del objeto que se define.
  Al ejecutarse por primera vez la función, se asigna el valor cero a la variable (\texttt{type = 0}).
  Después, se llama a g\_type\_register\_static para registrar el objeto en el sistema de tipos. En las subsecuentes
  llamadas, la función lo único que se hace es retornar el tipo que se definió en la primera ejecución.\par
  Cuando se utilicen las macros \texttt{G\_DECLARE\_FINAL\_TYPE} y \texttt{G\_DEFINE\_FINAL\_TYPE}, no será
  necesario definir la función esta función \passthrough{\lstinline!t\_doble\_get\_type!}; de esto se encargarán las macros anteriores.
\item Líneas 36--46:\par
  Establece campos de la estructura \texttt{info} y llama a \passthrough{\lstinline!g\_type\_register\_static!}.
\item Líneas 51--75:\par
  La función principal. Asigna a la variable \texttt{dtype} el tipo de objeto \textsf{TDoble} y escribe el valor
  del tipo \text{TDoble}.
\item Líneas 53--54:\par
  Se define la variable \texttt{dtype}, que guardará el tipo del sistema de objeto \textsf{T\_DOBLE}, y de la
  variable \texttt{d}, que es un puntero a la instancia de \textsf{T\_DOBLE}, que se creará en la línea 66.
\item Línea 58:\par
  Se le asigna la cadena vacía a la variable de estado \texttt{LC\_CTYPE} para que la función
  \passthrough{\lstinline!g\_print!} no cambie el el sistema de caracteres del texto que imprimirá.
  Esto funcionará si la consola que se utiliza para ejecutar el programa utiliza el mismo sistema de caracteres
  que las cadenas (en este caso utilizamos UTF-8).
\item Líneas 60--65:\par
  Se guarda en la variable \texttt{dtype} el valor del tipo de objeto \textsf{T\_DOBLE} y se muestra en la consola.
  También se podría haber sustituido esta línea por la equivalente, utilizando la macro de la línea 9:
  "\texttt{dtype = T\_TYPE\_DOBLE}".
\item Líneas 67--72:\par
  Se crea una instancia \textsf{T\_DOBLE} y se almacena en el puntero \texttt{d}. Se muestra en la consola su
  dirección. En la referencia de la API de \textsf{GObject} se dice que la función
  \passthrough{\lstinline!g\_object\_new!} returna un puntero a \textsf{GObject}, pero en realidad retorna un
  \texttt{gpointer}, que es lo mismo que \texttt{void *}, que puede asignarse a cualquier puntero, sea cual sea
  su tipo; en este caso, \texttt{d} se declaró como un puntero a \texttt{TDoble}, por lo que la línea
  "\texttt{d = g\_object\_new (T\_TYPE\_DOBLE, NULL)}" es correcta. Nótese que si la función
  \passthrough{\lstinline!g\_object\_new!} retornara un puntero a \textsf{GObject}, sería necesario indicarlo:
  "\texttt{d = (gpointer) g\_object\_new (T\_TYPE\_DOBLE, NULL)}".
\item Línea 74:\par
  Se elimina la instancia llamando a la función \passthrough{\lstinline!g\_object\_unref!}.
\end{itemize}

\subsection{Registro mediante la macro \texttt{G\_DEFINE\_TYPE}}
El proceso de registro realizado anteriormente se lleva a cabo siempre con el mismo algoritmo, por tanto,
el sistema puede definir una macro, como \texttt{G\_DEFINE\_TYPE}  que lo lleve a cabo automáticamente,
con solo invocarla.

\texttt{G\_DEFINE\_TYPE} hace lo siguiente:
\begin{itemize}
  \tightlist
\item Declara una función de inicialización de la clase. Su nombre es \textsf{<espacio-de-nombres>\_<nombre>\_class\_init}. Por ejemplo, para el objeto \textsf{TDoble}, la función
  sería \texttt{t\_doble\_class\_init}. Esto es una declaración, no una definición, por lo que necesitamos
  definirla más adelante.
\item Declara una función de inicialización para las instancias. Su nombre es
\textsf{<espacio-de-nombres>\_<nombre>\_init}. Por ejemplo, para el objeto \textsf{TDoble}, la función
sería \texttt{t\_doble\_class\_init}. Esto es una declaración, no una definición, por lo que necesitamos
definirla más adelante.
\item Define una variable estática que apunte a la clase de la que deriva. Su nombre es
  \textsf{<espacio-de-nombres>\_<nombre>\_parent\_class}. Por ejemplo, para el objeto \textsf{TDoble},
  la variable es \texttt{t\_doble\_parent\_class}.
\item Define una función \textsf{<espacio-de-nombres>\_<nombre>\_get\_type ()}. Por ejemplo para
  el objeto \textsf{TDoble}, la función es \texttt{t\_doble\_get\_type}. El registro se lleva a cabo como
  se hizo anteriormente.
\end{itemize}

Al usar esta macro se reduce en número de líneas de programa. Ver el ejemplo 4.

\subsubsection{Ejemplo 4}
Este ejemplo realiza lo mismo que el ejemplo 3, pero con menos líneas de código.
Gracias a \texttt{G\_DEFINE\_TYPE} no tenemos que escribir código como la variable \texttt{GTypeInfo info}
o definir la función  \passthrough{\lstinline!g\_type\_register\_static!}.
Es importante seguir las convención en el nombre de las funciones de inicialización.
A partir de \textsf{GLib 2.70} se puede utilizar la macro \texttt{G\_DEFINE\_FINAL\_TYPE} en lugar de
\texttt{G\_DEFINE\_TYPE}, para clases finales.

En el directorio 'prog' se encuentran los programas de ejemplo.
Para compilarlos todos basta con hacer
\begin{lstlisting}[language=bash]
  $ cd prog
  $ make
\end{lstlisting}
o bien, solo el cuarto ejemplo:
\begin{lstlisting}[language=bash]
  $ cd prog
  $ make ejemplo04
\end{lstlisting}
Para borrar los ejecutables:
\begin{lstlisting}[language=bash]
  $ cd prog
  $ make clean
\end{lstlisting}

El listado es:
\begin{lstlisting}[language=C, numbers=left]
/*
 * ejemplo04.c
 * Prueba la macro G_DEFINE_TYPE
 */

#include <locale.h>
#include <glib-object.h>

#define T_TYPE_DOBLE  (t_doble_get_type ())

typedef struct _TDoble TDoble;
struct _TDoble {
  GObject parent;
  double value;
};

typedef struct _TDobleClass TDobleClass;
struct _TDobleClass {
  GObjectClass parent_class;
};

G_DEFINE_TYPE (TDoble, t_doble, G_TYPE_OBJECT)

static void
t_doble_class_init (TDobleClass *class) {
}

static void
t_doble_init (TDoble *self) {
}

int
main (int argc, char **argv) {
  GType dtype;
  TDoble *d;

  // Para que g_print no transforme la codificación de caracteres
  // por su cuenta y no se vean los acentos.
  setlocale(LC_CTYPE, "");
  
  dtype = t_doble_get_type (); /* or dtype = T_TYPE_DOBLE */
  if (dtype) {
    g_print ("Registro correcto. El tipo es %lx.\n", dtype);
    } else {
      g_print ("Registro incorrecto.\n");
    }

  d = g_object_new (T_TYPE_DOBLE, NULL);
  if (d) {
    g_print ("La instancia se ha creado correctamente. Su dirección ess %p.\n", d);
    } else {
      g_print ("Error en la creación de la instancia.\n");
    }

  g_object_unref (d); /* Elimina el objeto 'd'. */

  return 0;
}
\end{lstlisting}

 \subsubsection{Salida del programa 'ejemplo04'}
\textsf{Registro correcto. El tipo es 0x55e94aa2d4f0.}\par
\textsf{La instancia se ha creado correctamente Su dirección es 0x55e94aa2e000.}\par

\subsubsection{Comentarios}
\begin{itemize}
\item Línea 9:\par
  Se define la macro \texttt{T\_TYPE\_DOBLE}, que se sustituye por la función
  \passthrough{\lstinline!t\_doble\_get\_type!}, se define automaticamente por el sistema y se ejecuta cuando
  se llama a la macro. Cuando se ejecuta, se registra la nueva clase y se crean las instancias que se pidan.
\item Líneas 11--15:\par
  Se define el tipo C del objeto \textsf{TDoble} y la estructura que lo define \texttt{struct \_TDoble}.
\item Líneas 17--20:\par
  Se define el tipo C de la clase \textsf{TDobleClass} y la estructura que lo define \texttt{struct \_TDobleClass}.
\item Línea 22:\par
  Se ejecuta la macro \texttt{G\_DEFINE\_TYPE}. El primer argumento es el nombre del objeto que se define,
  el segundo es \textsf{<espacio-de-nombres>\_<nombre>} en minúsculas, y el último es el objeto padre.
  En este ejemplo, los argumentos son: \texttt{TDoble}, \texttt{t\_doble} y \texttt{G\_TYPE\_OBJECT}.
  A partir de \textsf{GLib 2.70} se puede utilizar la macro \texttt{G\_DEFINE\_FINAL\_TYPE} para clases finales.
\item Líneas 24--30:\par
  Se definen las funciones que inicializan la clase y la instancia. El argumento \texttt{class} es un puntero a la
  estructura de la clase y \texttt{self} apunta a la estructura de la instancia. Como se aprecia, no
  necesitan ningún código en este caso, pero son necesarias para el registro.
\item Líneas 32--56:\par
  La función principal. Asigna a la variable \texttt{dtype} el tipo de objeto \textsf{TDoble} y escribe el valor
  del tipo \text{TDoble}.
\item Líneas 34--35:\par
  Se define la variable \texttt{dtype}, que guardará el tipo del sistema de objeto \textsf{T\_DOBLE}, y de la
  variable \texttt{d}, que es un puntero a la instancia de \textsf{T\_DOBLE}, que se creará en la línea 47.
\item Línea 39:\par
  Se le asigna la cadena vacía a la variable de estado \texttt{LC\_CTYPE} para que la función
  \passthrough{\lstinline!g\_print!} no cambie el el sistema de caracteres del texto que imprimirá.
  Esto funcionará si la consola que se utiliza para ejecutar el programa utiliza el mismo sistema de caracteres
  que las cadenas (en este caso utilizamos UTF-8).
\item Líneas 41-46:\par
  Se guarda en la variable \texttt{dtype} el valor del tipo de objeto \textsf{T\_DOBLE} y se muestra en la consola.
  También se podría haber sustituido esta línea por la equivalente, utilizando la macro de la línea 9:
  "\texttt{dtype = T\_TYPE\_DOBLE}".
\item Líneas 48--53:\par
  Se crea una instancia \textsf{T\_DOBLE} y se almacena en el puntero \texttt{d}. Se muestra en la consola su
  dirección. En la referencia de la API de \textsf{GObject} se dice que la función
  \passthrough{\lstinline!g\_object\_new!} returna un puntero a \textsf{GObject}, pero en realidad retorna un
  \texttt{gpointer}, que es lo mismo que \texttt{void *}, que puede asignarse a cualquier puntero, sea cual sea
  su tipo; en este caso, \texttt{d} se declaró como un puntero a \texttt{TDoble}, por lo que la línea
  "\texttt{d = g\_object\_new (T\_TYPE\_DOBLE, NULL)}" es correcta. Nótese que si la función
  \passthrough{\lstinline!g\_object\_new!} retornara un puntero a \textsf{GObject}, sería necesario indicarlo:
  "\texttt{d = (gpointer) g\_object\_new (T\_TYPE\_DOBLE, NULL)}".
\item Línea 55:\par
  Se elimina la instancia llamando a la función \passthrough{\lstinline!g\_object\_unref!}.
\end{itemize}

\subsection{La macro \texttt{G\_DECLARE\_FINAL\_TYPE}}
Otra macro útil es \texttt{G\_DECLARE\_FINAL\_TYPE}, que se puede usar para objetos de tipo final.
Los tipos finales no tienen hijos, esto es, no se pueden derivar objetos a partir de ellos.
En cambio, los tipos derivables permiten definir objetos hijos. Si quieres definir un objeto de tipo
derivable debes usar \texttt{G\_DECLARE\_DERIVABLE\_TYPE} en su lugar. Sin embargo, en la mayoría de
las ocasiones utilizarás objetos finales.

\texttt{G\_DECLARE\_FINAL\_TYPE} hace lo siguiente:
\begin{itemize}
  \tightlist
\item Declara la función \texttt{<espacio-de-nombres>\_<nombre>\_get\_type}. Esta es solo una declaración,
  Nosotros deberíamos definirla, pero usando la macro \texttt{G\_DEFINE\_TYPE}, se define la función
  automáticamente. Así, en realidad, no necesitamos escribir la definición de la función.
\item El tipo C del objeto se define aplicando \texttt{typedef} a una estructura. Por ejemplo, para el objeto
  \textsf{TDoble}, entonces se define el tipo C \texttt{TDoble}, mediante el comando
  \texttt{typedef struct \_TDoble TDoble}, aunque tendremos que definir la estructura \texttt{struct \_TDoble}
  antes de utilizar \texttt{G\_DEFINE\_...\_TYPE}.
\item Se define la macro \texttt{<ESPACIO-DE-NOMBRES>\_<NOMBRE>}. Por ejemplo, para el objeto
  \textsf{TDoble}, la macro será \texttt{T\_DOBLE}, que se expandirá a una función que ajusta el argumento
  a un puntero al objeto. Por ejemplo, \texttt{T\_DOBLE(obj)} ajusta el tipo de puntero a objeto a
  \texttt{TDoble *}.
\item Se define la macro \texttt{<ESPACIO-DE-NOMBRES>\_IS\_<NOMBRE>}. Por ejemplo, para el objeto
  \textsf{TDoble}, la macro será \texttt{T_DOBLE_\ID

\end{itemize}
  

%<NAME SPACE>_<NAME> macro is defined. For example, if the object is TDouble the macro is T_DOUBLE. It will be expanded to a function which casts the argument to the pointer to the object. For example, T_DOUBLE (obj) casts the type of obj to TDouble *.
%<NAME SPACE>_IS_<NAME> macro is defined. For example, if the object is TDouble the macro is T_IS_DOUBLE. It will be expanded to a function which checks if the argument points the instance of TDouble. It returns true if the argument points a descendant of TDouble.
%The class structure is defined. A final type object doesn't need to have its own member of class structure. The definition is like the line 11 to 14 in the example4.c.



%%% Local Variables:
%%% coding: utf-8
%%% mode: latex
%%% TeX-engine: luatex
%%% TeX-master: "../GObject_tutorial_es.tex"
%%% End:

% LaTeX-command: "lualatex --shell-escape"
